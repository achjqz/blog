<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>潇晗宇浩的博客</title>
    <link>https://blog.xhyh.tech/</link>
    
    <atom:link href="https://blog.xhyh.tech/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>记录生活</description>
    <pubDate>Thu, 31 Dec 2020 12:30:30 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>2020 总结</title>
      <link>https://blog.xhyh.tech/talk/2020-summary/</link>
      <guid>https://blog.xhyh.tech/talk/2020-summary/</guid>
      <pubDate>Thu, 31 Dec 2020 12:30:30 GMT</pubDate>
      
      <description>&lt;p&gt;2020 无疑是 breaking change 的一年，虽然过得很快，又被疫情烦扰，但感觉应该是自己近几年经历最多的一年了，去过了一些原来从没到过的地方，认识了不少的人，自我的变化也挺大的。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>2020 无疑是 breaking change 的一年，虽然过得很快，又被疫情烦扰，但感觉应该是自己近几年经历最多的一年了，去过了一些原来从没到过的地方，认识了不少的人，自我的变化也挺大的。</p><span id="more"></span><h3 id="一年大事迹">一年大事迹</h3><blockquote><p>1月</p></blockquote><p>和 <em>顺</em> 关系越来越好，但寒假到了不得不分别，心里又产生了那种依赖感，我知道很不好，但始终没有调整过来，本来该好好准备面试，每天心情却很低落。</p><p>过年回老家，正好疫情开始爆发了，也是过了最冷清的一个年了。还好还是去表弟家玩了几天，晚上睡觉前一起聊天，虽然很久没见面联系，但还是能一起抱团取暖，这感觉真的好。</p><blockquote><p>2月</p></blockquote><p>和 <em>顺</em> 联系越来浅了，期待着回学校，然而疫情越来越严重，在家也打不起精神，每天看 <em>散人</em> 玩<strong>冬日计划</strong>，意外看到他和 <em>怪异君</em> 连麦推荐动漫和小说，我从里面选了<strong>朋友游戏</strong> 和 <strong>彩虹牙刷</strong>来看，这两个都是剧情向的，都很精彩，看完后也渐渐忘记了 <em>顺</em> 的事，情绪也变得平稳了，这时候不得不开始准备面试，投简历。</p><blockquote><p>3月</p></blockquote><p>开始了疯狂的面试，腾讯问的问题是最合我胃口的，大多都是<strong>深入理解计算机系统</strong>里面的内容(后面去实习发现他们人手一本)，字节简历在冷冻期，最后只好选择去了腾讯。</p><blockquote><p>4月 5月</p></blockquote><p>开始进入放松期，重新打理了下博客，看完了<strong>请回答1988</strong>，开始学习 flutter，开发 share 应用，开始看<strong>体面开放麦</strong>，买了 iPhone se2，无聊到拿新手机剪开放麦视频</p><blockquote><p>6月</p></blockquote><p>学校公布了可返校时间，马上就决定了去腾讯实习的日子，然后开始做一些准备。</p><p>为了把我的 share 编译出 iOS 版本，突然又想折腾黑苹果了，看到有人发了直接换网卡解决 wifi 问题的视频，我突然心血来潮也想搞一波，网卡都买好了最后才发现技术有限，没人会焊接。后面又发现有人在开发 Intel wifi 驱动，处于基本可用状态，于是买了块硬盘，装上了黑苹果，体验也变得很完美了</p><blockquote><p>7月 8月</p></blockquote><p>在腾讯实习，第一次接触工作上的开发，刷新了我对面试和工作的认知。面试基本就是从题库里面问，也很难问出和工作实际相关的，leader(二面) 和 总监(三面)其实水平都不高(基本不写代码了)，面试也就重复那套自己很熟悉的流程和问题。对工作也没有我原来想象中那么不适，基本就是发现问题，解决问题，还是挺爽的。</p><p>这期间也挺开心的，<strong>脱口秀大会</strong>开播，快乐源泉，和好久没联系的 <em>Lizzie</em> 又有交集了(又产生了不切实际的幻想), 开始了属于我们两个的<em>分享计划</em></p><blockquote><p>9月</p></blockquote><p>回到学校准备秋招，感觉上腾讯那边转正肯定稳了，于是就打算面一下字节了，当然怀着一份情怀，还是去面了b站 和小米。面试得很顺利，感觉自己是处于一种‘看透了’的状态。</p><p>字节面过了后又进入了放松期，和 <em>顺</em> 开始了新的健身计划，给我自己定的任务是学 SICP 和 日语，可能以后工作后就没时间搞这些了，还有就是想提高一下自己的专注度，总感觉好久没有很专注做一件事了</p><blockquote><p>10月</p></blockquote><p>每天去自习室 + 健身计划，应该没怎么用眼但总感觉眼睛很累，大部分时间在<em>立人楼</em> 游荡放松眼睛，同时听着播客，把<strong>一言不合</strong>和<strong>谐星聊天会</strong>补完了，听了后整个人都被影响了</p><p>本来打算培养自己的专注能力，但到月末发 offer 时刻还是很难静下心来，总是在挂念这件事，为了转移注意力就只有玩手机之类的，看了<strong>说唱新世代</strong>，刷新了我对说唱的认识，里面有些歌还真挺喜欢的</p><blockquote><p>11月</p></blockquote><p>月初进入了极度难受的状态，没料到腾讯发了一个白菜价 offer，，字节也发了一个白菜价，部门也一般，可能就这样也能接受吧，然而室友和其他人的 offer 又很不错，虽然没有太过沮丧，但心里总是过不去这个坎，同时又计划马上来实习了，又伴随着和 <em>顺</em> 的分别（可能真的是永别了），心情极其难受。最终很快选了实习时间，最后的时光看了<strong>半泽直树</strong>，瞬间转换到了北京开始实习。</p><blockquote><p>12月</p></blockquote><p>很快进入到了工作状态，也渐渐接受了现状，新的工作环境还是挺喜欢的，认识到了更多的人。目前对我来说身边什么样的人对我可能影响更大一些，脑中始终浮想起<strong>半泽</strong>里面的那句话—— <strong>不能像机器人一样工作</strong></p><h3 id="重要的事">重要的事</h3><p>今年工作问题贯穿始终，首先是方向问题，年初还在投<strong>后台</strong>方向的工作，阴差阳错到了腾讯<strong>iOS</strong>组，到最后头条<strong>Android</strong>组。当初选择转战<strong>后台</strong>也是觉得可能发展前景更好一点，但客户端的东西自己还是更热爱一点，几经波折还是到了客户端岗。目前工作主要还是干全栈的活，我不知道这样对职业发展是否有利，这也是最近很困扰我的问题，什么才是真正的工作实力？</p><p>还有就是公司选择问题，按道理腾讯应该更适合应届生发展一些，我对深圳的印象也远比北京好，此外如果去头条还得面对未知的部门情况，最终还是选择了头条。一直和腾讯那边沟通也没说出我真实的想法，只说了觉得 offer 评级和能力不匹配，其实还有其他方面的考量。一个是想多去不同的地方体验一下，我越来越觉得自己不会满足于平稳的生活，而是尽可能的去感受些新的事物；第二个是想换个公司改变自己的形象重新做人，在腾讯过于像机器人一样工作了，想要扭转还挺困难的。第三个是腾讯健身计划很难实施，同事之间真正的交流很少，实习和应届生在我们组都没有。虽然来字节这些问题也可能不会解决，但总是有一点可能的吧，当然如果腾讯真的给到了一个更高一级的 offer，可能真就和字节无缘了，也不会有现在这样新的生活，最近也越来越相信 <strong>这是上天最好的安排</strong> 这句话了</p><p>对于秋招感觉自己还是不够有经验，最终导致双双白菜价的局面，但可惜，每个人都只有这一次机会</p><p>来字节一个多月，本来还只是实习，但给我一种错觉，我好像已经开始工作好久了。字节这边最让我开心的还是走得最近的同事我都还挺喜欢的，这样可以满足一部分我的表达欲吧，和他们相处会很放松，放松了才会抛梗。字节这边新人也挺多的，也比较好怂恿一起健身，一起吃饭啥的，这点比腾讯强太多了</p><h3 id="我的朋友们">我的朋友们</h3><blockquote><p>顺</p></blockquote><p><em>顺</em> 是我交流的重点对象，毕竟认识时间不长，又马上会分别，还是希望能把我能想到的事情都做了。寒假前都黏在一起，去了西华遛弯，一起坐地铁回家，寒假督促学习<strong>csapp</strong>。</p><p>4月趁他咨询考研工作的事讲了一波我的经历，把有些原本离别想说的提前说了。</p><p>下半年开学后一起开始了新的健身计划，把能聊的天都聊完了。10月去了沙河玩了一转，还有点小不愉快，主要是我想着要分别了，想做一些原来没做过的事，这样自己才不会后悔。</p><p>来实习之后基本就不联系了，把外包工作推给了他。<em>顺</em> 就像我种下的一颗种子，这一两年我尽可能地浇水施肥，也确实长得不错，但最终可能没有开花，有点小失落吧。所以离别后我也不想怎么找他了，如果强行的话最终还是我受伤，也许会有那么一天到来吧。</p><blockquote><p>玮</p></blockquote><p>和 <em>玮</em> 已经两年没见面了，但我真没感觉到有陌生感，交流还挺频繁的，有啥好玩的或者有啥新闻都会给他分享，虽然交流不深但我感觉我始终需要这样一个人。</p><p>下半年开学后终于见了一次面，直到他谈恋爱了，这时候开始我下意识的会避开之前频繁的分享，一方面是可能觉得他已经不需要我了，另一方面是我也觉得不应该发给他了，应该构思一下发给 <em>Lizzie</em> 之类的。想想 <em>乔</em> 当时谈恋爱的时候对我影响更大吧，不过当时和 <em>乔</em> 交流本就不频繁，所以也没有如今很大的落差感</p><blockquote><p>强</p></blockquote><p>年初 <em>强</em> 也开始找实习所以交流变多了，最爽的还是我在备份 qq 聊天记录时候拿原来的记录对他嘲讽，他的回复瞬间让我感觉我们两个换位，我变成了那个在’上面’的人。</p><p>疫情好转也一起出来玩，但我印象里每次和他出来玩都不怎么美好。</p><p>我们都开始实习了聊技术问题也挺多的，晚上也经常聊一些哲学问题，每次聊完都有些激动，感觉思想上的距离又近了很多。但到我实习快结束的时候交流巨减，强觉得我经常问一些细节问题，发出了不满，我生气了，就很少找他聊天了。后面聊了聊投资相关的，也没了下文。</p><blockquote><p>乔</p></blockquote><p>和 <em>乔</em> 的交流很固定，每个月的电话交流，所以 <em>乔</em> 应该是最了解我大学生活的人，疫情好转也一起去逛宜家聊天，很早就和他普及了投资相关的，也安利了脱口秀大会，谐星聊天会，<em>乔</em> 虽然忙于学习，但对这些东西的接受度是朋友们里最好的，每次聊天也有更多的东西能交流了，当然每次最主要的还是聊他的感情问题。</p><blockquote><p>Lizzie</p></blockquote><p>上半年几乎没有交流，到腾讯后突然开始聊起来了，后面又提出了分享计划，<em>Lizzie</em> 总能带给我惊喜，其他人是我来搞事情，<em>Lizzie</em> 总能在我之上又提出很多有意思的想法和观点。所以 <em>Lizzie</em> 一提出这个我就马上开始搞了，在 notion 上搭好了分享平台，慢慢也运作起来了。</p><p>实习结束后又和 <em>Lizzie</em> 见了一面，每次和 <em>Lizzie</em> 一起出去玩总是感觉很愉快，总是能一起聊到一些点上。</p><p>下半年开学后我也尽可能的和 <em>Lizzie</em> 保持交流，并且有意识地输出一些我的观点，希望能有些用吧。</p><h3 id="意外的‘朋友’">意外的‘朋友’</h3><blockquote><p>prime</p></blockquote><p>一直觉得和 <em>prime</em> 之间存在着隔阂而无法成为真正的朋友，但今年由于一起找工作，一起实习，交流也变得多了起来。我很喜欢 <em>prime</em> 身上那种企业家，怀揣远大梦想的气质。印象最深的还是他编了一个女生故事来和我聊天，我还一本正经给他一波分析，不过也挺有趣的。我能感受到我在 <em>prime</em> 心中慢慢符合了他对朋友的认知，但我始终觉得和 <em>prime</em> 没法做到我理想中朋友的那种很真诚的交流。</p><blockquote><p>煦</p></blockquote><p>一直以来和 <em>煦</em> 关系都不错，从狼人杀开始认识，到后面一起找实习，交流也越来越多。最后到北京也多亏有她陪着，也一起约吃饭，去故宫。煦有什么私事或者八卦也会找我分享，我能感觉到她对我的认可和信任，但我始终觉得我们之间还差点东西，可能是没有 <em>Lizzie</em> 带给我的那份惊喜感吧</p><blockquote><p>扬</p></blockquote><p><em>扬</em> 的出现真的是意外吧，很早就放弃了，但始终心里是放不下的。本来计划不去实习，寒假找他出来聊聊天，重新认识一下，不然后面工作就没机会了。最后又决定来实习，感觉计划落空，但突然一天又意外地聊了起来，希望后面有个完美的结局吧。</p><h3 id="个人成长">个人成长</h3><p>今年自己最大的变化是开始追求搞笑了，听了很多播客，被同化了，学习到了很多找梗方式，在生活中也开始有意识地去发现一些灵感。</p><p>这件事带给我的能量和成就感比我想象中的还要大，有时候想到一个好玩的即使没有给别人讲就已经很满足了。最大的快感还是和熟悉的人面对面聊天，聊天内容反而不太重要了，重要的是放飞思想。</p><p>这个变化好像是让我变得能自娱自乐一点了，原来总是依赖我的朋友们，算是找到了一个和自己相处的小技能。</p><h3 id="投资总结">投资总结</h3><p>今年新接触到 etf 和 网格交易，目前来看还是很不错的策略。</p><p>总体今年场外基金收益率 25% 左右，比去年有所提高，但主要是由于年后疫情股市大跌，买到了不少便宜的，但之后股市一直在偏高的位置浮动，也没有投入过多的资金。</p><p>新的网格交易收益率在 15%左右，主要问题在波动还是太小，经常在3，4个点之间来回浮动<br><br></p><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/talk/">talk</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/summary/">summary</category>
      
      <category domain="https://blog.xhyh.tech/tags/annual/">annual</category>
      
      
      <comments>https://blog.xhyh.tech/talk/2020-summary/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>docker 部署 nginx 和 UnblockNeteaseMusic</title>
      <link>https://blog.xhyh.tech/tutorial/docker-unblock/</link>
      <guid>https://blog.xhyh.tech/tutorial/docker-unblock/</guid>
      <pubDate>Tue, 03 Nov 2020 02:39:40 GMT</pubDate>
      
      <description>&lt;p&gt;每次配置 nginx 都是一件烦人的事，原来尝试用过 &lt;code&gt;docker-compose-letsencrypt-nginx-proxy-companion&lt;/code&gt;, 一键生成证书，配置 nginx，反向代理服务。但用了后发现也没有那么方便，体量太重，也不好自己定制化修改配置，于是自己写了 docker-compose，方便配置 nginx，也方便接入新的服务。这里以解锁网易云音乐为例，将整个流程走一遍&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>每次配置 nginx 都是一件烦人的事，原来尝试用过 <code>docker-compose-letsencrypt-nginx-proxy-companion</code>, 一键生成证书，配置 nginx，反向代理服务。但用了后发现也没有那么方便，体量太重，也不好自己定制化修改配置，于是自己写了 docker-compose，方便配置 nginx，也方便接入新的服务。这里以解锁网易云音乐为例，将整个流程走一遍</p><span id="more"></span><h3 id="需求">需求</h3><p>按照 UnblockNeteaseMusic (下面简称unblock) 的 <a href="https://github.com/nondanee/UnblockNeteaseMusic/issues/368">iOS配置经验</a> 所说</p><blockquote><p>iOS比较特殊的另外一点是他会在下载第三方音源时，将它们的 HTTP 地址先替换成 HTTPS 地址再去请求。而很多第三方音源不支持 HTTPS 访问（证书错误且资源不存在，表现就是歌曲虽然亮起来，但是无法播放，报错“网络不给力，播放失败”)</p></blockquote><p>最优雅的解决方案就是启用 endpoint 功能，将第三方音源的地址包裹在自己域名下转发</p><p>大致原理: unblock 找到歌曲的第三方歌源 -&gt; unblock 返回被包裹地址(<code>https://your-domain.com/package/&#123;真实地址编码&#125;</code>) -&gt; iOS 客户端请求该地址 -&gt; nginx 转发该请求到 unblock -&gt; unblock 取出真实地址 -&gt; unblock 请求歌曲内容并返回 -&gt; iOS 客户端成功播放</p><p>从上面流程可以看出其实就是搭建一个 nginx，反向代理到 unblock，下面讲如何使用 docker 达到这个效果</p><blockquote><p>仓库地址: <a href="https://github.com/achjqz/nginx">https://github.com/achjqz/nginx</a></p></blockquote><h3 id="申请-SSL-证书">申请 SSL 证书</h3><p>按照 <a href="https://certbot.eff.org/lets-encrypt/debianstretch-nginx">certbot</a> 官方流程申请免费的 SSL 证书</p><p>具体命令也可以参考 <a href="https://github.com/achjqz/nginx/blob/main/install-certbot.sh">我的仓库</a></p><div class="danger"><p>免费域名，如 .tk, .ga 会申请失败</p></div><p>申请成功后证书可以在<code>/etc/letsencrypt/live/</code>中找到</p><h3 id="修改配置">修改配置</h3><ol><li><p>修改证书位置</p><p>在 <a href="https://github.com/achjqz/nginx/blob/main/docker-compose.yml">docker-compose.yml</a> 中修改 volumes</p> <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="comment"># 将 music.xhyh.tech 改为自己域名地址</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/etc/letsencrypt/live/music.xhyh.tech/fullchain.pem:/etc/nginx/certs/music/fullchain.pem:ro</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/etc/letsencrypt/live/music.xhyh.tech/chain.pem:/etc/nginx/certs/music/chain.pem:ro</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/etc/letsencrypt/live/music.xhyh.tech/privkey.pem:/etc/nginx/certs/music/privkey.pem:ro</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure></li><li><p>修改 endpoint 地址</p><p>在 <a href="https://github.com/achjqz/nginx/blob/main/music/docker-compose.yml">music/docker-compose.yml</a> 中修改 command</p> <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># 修改 music.xhyh.tech 为自己的域名</span></span><br><span class="line"><span class="attr">command:</span> <span class="string">-s</span> <span class="string">-e</span> <span class="string">https://music.xhyh.tech</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure></li><li><p>修改 nginx config</p><p>在 <a href="https://github.com/achjqz/nginx/blob/main/nginx-data/music.conf">nginx-data/music.conf</a> 中 修改 server_name</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_name music.xhyh.tech; # 改为你自己的域名</span><br></pre></td></tr></table></figure><blockquote><p>如果部署在阿里云又没有备案，则可以把 443 端口换成 2096, 这样可以规避备案提醒</p></blockquote></li></ol><h3 id="部署服务">部署服务</h3><ol><li><p>安装<code>docker</code>和<code>docker-compose</code></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># install docker</span></span><br><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># install docker-compose</span></span><br><span class="line"></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.27.4/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></li><li><p>创建 network</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx 和 music 都会使用该网络 </span></span><br><span class="line">docker network create webproxy</span><br></pre></td></tr></table></figure></li><li><p>运行 unblock</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> music</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li><li><p>运行 nginx</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 退回到项目根目录</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li></ol><br><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/tutorial/">tutorial</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/docker/">docker</category>
      
      <category domain="https://blog.xhyh.tech/tags/nginx/">nginx</category>
      
      
      <comments>https://blog.xhyh.tech/tutorial/docker-unblock/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Git 使用小技巧</title>
      <link>https://blog.xhyh.tech/study/git-tips/</link>
      <guid>https://blog.xhyh.tech/study/git-tips/</guid>
      <pubDate>Thu, 08 Oct 2020 06:17:41 GMT</pubDate>
      
      <description>&lt;p&gt;工作以后, Git 几乎是每天都会使用的工具, 本篇主要针对工作中的场景, 总结一些小技巧&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>工作以后, Git 几乎是每天都会使用的工具, 本篇主要针对工作中的场景, 总结一些小技巧</p><span id="more"></span><h3 id="使用-reabse-进行分支合并">使用 reabse 进行分支合并</h3><p>git merge 和 rebase 的区别如下图所示, git rebase 能得到一个干净的历史</p><p><img src="https://pic.rmb.bdstatic.com/bjh/6803ef1bc4272a01ac73d0c932a2d42d.png" alt="merge-rebase"></p><h3 id="使用-rebase-进行-commit-压缩">使用 rebase 进行 commit 压缩</h3><p>使用<code>git rebase -i</code>进入可视化选择界面, 一般第一个选 pick, 其余改为 s</p><p><img src="https://pic.rmb.bdstatic.com/bjh/dfdc8b3f8e939d669bbc1fe6eb9974fc.png" alt="rebase"></p><h3 id="清空工作空间">清空工作空间</h3><p>若不需要保存已修改文件可以用<code>git reset --hard HEAD</code></p><p>若需要保存则使用<code>git stash push -u</code>, 恢复使用<code>git stash pop</code></p><h3 id="补充上一个-commit">补充上一个 commit</h3><p>修改文件后使用<code>git commit --amend</code> 提交</p><h3 id="找回丢失的-commit-节点或分支">找回丢失的 commit 节点或分支</h3><p>使用<code>git reflog</code>找到要返回的commit object的哈希值, 然后执行<code>git reset</code>恢复</p><h3 id="移除历史-commit-中的文件">移除历史 commit 中的文件</h3><p>使用 <code>git-filter-branch</code> 或者 <a href="https://rtyley.github.io/bfg-repo-cleaner/">BFG</a><br><br></p><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/study/">study</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/summary/">summary</category>
      
      <category domain="https://blog.xhyh.tech/tags/git/">git</category>
      
      
      <comments>https://blog.xhyh.tech/study/git-tips/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GTD 时间管理</title>
      <link>https://blog.xhyh.tech/talk/gtd-time-manager/</link>
      <guid>https://blog.xhyh.tech/talk/gtd-time-manager/</guid>
      <pubDate>Sat, 05 Sep 2020 07:59:17 GMT</pubDate>
      
      <description>&lt;p&gt;自从被人安利了 GTD 后, 看了不少视频和文章, 自己也实践了一个多月, 本文主要谈谈自己对于 GTD 的理解和我的实践方法&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>自从被人安利了 GTD 后, 看了不少视频和文章, 自己也实践了一个多月, 本文主要谈谈自己对于 GTD 的理解和我的实践方法</p><span id="more"></span><div class="warning"><p>本篇内容带有强烈的主观色彩, 仅代表个人理解</p></div><h3 id="什么是-GTD">什么是 GTD</h3><p>GTD 的全称为 Get Things Done, 直译为 ‘把事情完成’</p><p>GTD 的理念不是追求 计划目标的<strong>数量</strong>, 而是提供一套 把一堆杂乱的事情安排得合理且井井有条的 <strong>法则</strong></p><h3 id="GTD-的作用">GTD 的作用</h3><p>GTD 并不是神一样的东西, 它只是一个安排任务的方法, 并不能提高做事的效率之类的</p><p>对我而言, 使用 GTD 的目的有四个</p><ol><li><p>清空大脑, 把大脑从要<strong>做什么</strong>和<strong>怎么做</strong>的混乱中解救出来</p><p>如果开始做一件事情了才开始想怎么做, 无疑会让我感到焦躁, 甚至会直接放弃</p></li><li><p>让自己随时都明确知道下一步该做什么</p><p>忙的时候还好, 有很多事等着完成, 但突然清闲下来, 大概率会不知道做什么, 又感觉自己有很多事想做, 需要去做</p></li><li><p>提高做事的专注度</p><p>很多时候在做一件事时, 会突然想起另外一件事, 可能就打断了当前的任务, 转手去做其他事了, 但其他事又没那么重要, 导致该完成的任务没有完成</p></li><li><p>跳出舒适圈</p><p>我自己在习惯了一个环境的生活后就慢慢进入了舒适圈, 但其实这样会麻痹自己, 感觉自己做了很多事, 但其实这样的生活很有问题</p></li></ol><p>下面会详细说说 GTD 是怎么帮助我达到这几个目的的</p><h3 id="GTD-的流程">GTD 的流程</h3><p>新的 GTD 流程分为 捕获（Capture）、明晰（Clarify）、组织（Organize）、回顾（Reflect）、执行（Engage）五个步骤<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><ol><li><p>捕获</p><p>把想做的, 应该做的事都放进收集箱（Inbox）中</p></li><li><p>明晰 和 组织</p><p>把收集箱中的事一件件拿出来, 想清楚如何做, 什么时候做, 然后放到合适的分区中<br><img src="https://pic.rmb.bdstatic.com/bjh/af3187b7b31ba8480d5548bfa869b7fd.png" alt="partition"></p></li><li><p>回顾</p><p>回顾你所有的清单, 查出错漏, 可分为每天回顾和每周/月总结</p></li><li><p>执行</p><p>按照计划完成任务</p></li></ol><h3 id="GTD-实践">GTD 实践</h3><p>我选择了两款软件作为辅助工具, 一个是 Microsoft To Do<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>, 一个是 Google Calendar<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>, 选择这两款主要是因为他们对跨平台支持比较好</p><p>首先在ToDo上建立好分区文件夹, 默认的’任务’为执行清单, 此外额外新建了项目, 等待, 收集, 可能, 回收清单</p><img src="https://pic.rmb.bdstatic.com/bjh/59bc716fafbe5204addf2effbd708689.png" alt="todo" style="zoom:25%;" /><p>然后进入 GTD 的五个步骤</p><ol><li><p>捕获</p><p>对我来说, 一般来说都是在完成一件任务是突然想到要做什么, 然后会马上记在 Inbox 中<br>当然有时候也会集中想一下接下来想要做的事</p></li><li><p>每天回顾 / 明晰 / 组织</p><p>一般在晚上挑个实践, 看一下各个清单的事, 完成一些可以立即做的, 然后规划一下明天要做的任务, 什么时候做, 怎么去做</p></li><li><p>执行</p><p>严格按照规划好的任务执行</p></li></ol><h3 id="遇到的问题">遇到的问题</h3><ol><li><p>经常忘记每日回顾</p></li><li><p>定好了任务但不想做/没精神做<br><br></p></li></ol><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>TopBook: 如何系统地学习 GTD 时间管理？<a href="https://topbook.cc/overview?selectedArticle=1727">https://topbook.cc/overview?selectedArticle=1727</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>Microsoft To Do: <a href="https://to-do.microsoft.com/tasks/">https://to-do.microsoft.com/tasks/</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>Google Calendar: <a href="https://calendar.google.com/">https://calendar.google.com/</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/talk/">talk</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/summary/">summary</category>
      
      <category domain="https://blog.xhyh.tech/tags/GTD/">GTD</category>
      
      
      <comments>https://blog.xhyh.tech/talk/gtd-time-manager/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>区分进程, 线程和协程</title>
      <link>https://blog.xhyh.tech/study/process-thread-coroutine/</link>
      <guid>https://blog.xhyh.tech/study/process-thread-coroutine/</guid>
      <pubDate>Sun, 30 Aug 2020 11:30:47 GMT</pubDate>
      
      <description>&lt;p&gt;在日常使用中, 其实能很明显感觉进程, 线程和协程是完全不一样的概念. 但一旦深入到底层, 这三者又有些难以区分, 本篇从本质上看看三者的区别&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>在日常使用中, 其实能很明显感觉进程, 线程和协程是完全不一样的概念. 但一旦深入到底层, 这三者又有些难以区分, 本篇从本质上看看三者的区别</p><span id="more"></span><h3 id="关于线程说明">关于线程说明</h3><p><abbr title="Native POSIX Thread Library">NPTL</abbr><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>是 Linux 2.6 引入的新的线程库实现，符合 POSIX 在线程方面的标准，用来替代旧的 LinuxThreads 线程库。不管是NPTL还是LinuxThreads，用户创建的每个线程都对应着一个内核态的线程。若无特殊说明，这里的线程特指操作系统内核线程</p><h3 id="进程和线程">进程和线程</h3><p>之所以将进程和线程放一块是因为在 Linux 里面，无论是进程，还是线程，到了内核里面，统一都叫任务<br>（Task），由一个统一的结构<code>task_struct</code>进行管理<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p><img src="https://pic.rmb.bdstatic.com/bjh/43699624f35d6daf890e3a68b948e518.png@s_0,w_2000" alt="image-20200830195551210"></p><blockquote><p>通常所说的pcb在linux中就是task_struct</p></blockquote><h4 id="任务ID">任务ID</h4><p>那么如何区分在不同进程的线程呢？</p><p><code>task_struct</code>中有如下字段定义任务ID</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">pid_t</span> tgid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span></span><br></pre></td></tr></table></figure><p>其中pid 是 process id，tgid是 thread <strong>group</strong> ID<br>若一个进程只有主线程， pid，tgid，group_leader 均为自己<br>若一个进程创建了其他线程，线程有自己的 pid，tgid 是进程主线程的 pid，group_leader 也指向主线程</p><p>有了tgid，在任务切换的时候就知道是 线程上下文切换 还是 进程上下文切换了</p><h4 id="创建过程">创建过程</h4><p>进程是通过<code>fork</code>系统调用创建，而线程是<code>pthread_create</code>，最终为什么都是task了呢？</p><ul><li><p>进程创建完全通过系统调用实现</p><p><code>fork</code>系统调用的过程主要有两个重要的事件</p><ol><li><p>调用sys_fork-&gt;do_fork，将<code>task_struct</code>结构复制一份并且初始化</p><p><img src="https://pic.rmb.bdstatic.com/bjh/3dd3bb8b3bb198ae94ef4f9089821786.png" alt="image-20200830212651155"></p></li><li><p>试图唤醒新创建的子进程</p></li></ol></li><li><p>线程创建是由内核态和用户态合作完成的<br>pthread_create 不是一个系统调用，而是 Glibc 库(nptl/pthread_create.c中)的一个函数<br>在用户态也有一个用于维护线程的结构(pthread)</p><p>大致的步骤如下:</p><ol><li>用户态创建线程栈，存放在堆中(通过mmap分配)</li><li>系统调用clone-&gt;do_fork复制 task_struct<blockquote><p>这里复制的时候由于clone_flags的影响，要么只是引用计数增加，要么直接指向原来的结构</p></blockquote></li><li>用户态执行通用的 start_thread -&gt; 调用用户指定函数<blockquote><p>和创建进程不同，clone在子线程返回时，我们还需要修改栈指针和指令指针，栈顶指针应该指向新线程的栈，指令指针应该指向线程将要执行的那个函数</p></blockquote></li></ol></li></ul><h4 id="上下文切换">上下文切换</h4><ol><li>前后两个task属于不同进程。资源不共享，判断为进程上下文切换，需要切换进程空间(虚拟内存)，也需要切换寄存器和 CPU上下文。</li><li>第二种，前后两个线程属于同一个进程。资源不共享，判断为进程上下文切换，只用切换寄存器和 CPU上下文。</li></ol><h3 id="协程">协程</h3><p>协程被称为‘轻量级的线程’，但我觉得是有点误导，因为协程和内核线程毫无关系</p><p>协程应该被叫做‘用户态的线程’比较好理解，也就是说，协程是一个能挂起并且一段时间后恢复执行的东西，并且不需要操作系统调度的参与，完全由各个语言自己实现</p><p>根据具体实现大致可分为</p><ol><li>有栈协程(Stackful Coroutine)：每一个协程都会有自己的调用栈，类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。如 goroutine</li><li>无栈协程(Stackless Coroutine)：协程没有自己的调用栈。如 JavaScript 、 C# 和 Python</li></ol><p>无栈协议栈是由CPS(continuation-passing-style)来保存上下文，这里不做过多介绍<br><br></p><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Wikipedia: Native POSIX Thread Library <a href="https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library">https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>趣谈Linux操作系统: <a href="https://time.geekbang.org/column/intro/164">https://time.geekbang.org/column/intro/164</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/study/">study</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/os/">os</category>
      
      <category domain="https://blog.xhyh.tech/tags/process/">process</category>
      
      <category domain="https://blog.xhyh.tech/tags/thread/">thread</category>
      
      <category domain="https://blog.xhyh.tech/tags/coroutine/">coroutine</category>
      
      
      <comments>https://blog.xhyh.tech/study/process-thread-coroutine/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>在腾讯实习的两个月</title>
      <link>https://blog.xhyh.tech/talk/internship-tencent/</link>
      <guid>https://blog.xhyh.tech/talk/internship-tencent/</guid>
      <pubDate>Fri, 21 Aug 2020 08:59:35 GMT</pubDate>
      
      <description>&lt;p&gt;第一次实习是去年的暑假, 当时就在成都实习, 也有几个小伙伴一起, 没有特别大的感触. 这一次一个人来到深圳实习, 有不少事都可以说一说, 由此纪念这一次还算美好的实习生活&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>第一次实习是去年的暑假, 当时就在成都实习, 也有几个小伙伴一起, 没有特别大的感触. 这一次一个人来到深圳实习, 有不少事都可以说一说, 由此纪念这一次还算美好的实习生活</p><span id="more"></span><h3 id="准备">准备</h3><p>小时候，总是觉得自己很独立，但真正一个人要出门了，心里突然觉得很难受，但在父母面前还是装作一副镇定。父母却表现得不太稳重，知道我要去外地实习后突然有一丝慌张，特别是母亲，开始各种联系熟人，打听深圳的情况。我印象里，母亲从来都是放任我不管，6岁的时候就敢直接把我’扔进’客车，让我一个人随缘回老家。小时候总是这样，天真无知的我没出什么意外现在想来也是神奇。</p><p>虽然我的内心充满了担心和惶恐，但一切都在有条不紊地推进中，定机票，找租房信息，收拾东西，一切都慢慢推着我向前走。</p><h3 id="飞机">飞机</h3><p>这是我第一次坐飞机，提前3个小时到了机场，怀着忐忑的心情，仍然对未来充满了恐慌。第一次做飞机也差点踩坑，我以为登机时间是指开始过安检的时间，一直等到登机时间到了才去安检，那时候幸好人不算很多，安检完才发现只剩5分钟飞机就要起飞了，赶紧跑过去登机才正好赶上。</p><p>第一次做飞机的感受也很奇妙，本以为会有他们所说的耳朵疼的现象，但对我来说只是耳朵气压的变化而已。一直担心飞机会不会出什么意外，但明显也是我想多了，2个小时后，我平安地抵达了深圳。</p><h3 id="初来乍到">初来乍到</h3><p>来深圳的第一印象是，和成都好像啊。除了略微更加潮湿的空气外，温度，街道，地铁，公交，人，都和成都几乎一样。当然还是得吐槽公交车，感觉还是上个年代的，成都的公交车不知道已经换了几代了。</p><img src="https://pic.rmb.bdstatic.com/bjh/9d83f6e9100b9b76efd8fd82364cc075.jpeg@s_0,w_1242" alt="深夜深圳" style="zoom: 25%;" /><p>到酒店后，恐慌的情绪终于消减了不少，有一丝激动地去外面找夜宵吃，祈祷深圳的东西能够符合我的胃口，不然工作了又会变瘦不少。找了一家看起来干净简单的牛杂粉面店，点了个招牌菜试试，对我来说只能算一般，必须加点辣椒酱才能吃完，不过也并没有因此担心未来的饮食生活。</p><img src="https://pic.rmb.bdstatic.com/bjh/97cfa3706c683331b1682d510e6b4ba2.jpeg@s_0,w_1242" alt="夜宵" style="zoom:25%;" /><h3 id="新房">新房</h3><p>对于租房，来深圳前一个星期就开始找各种信息了，最后发现最靠谱的居然是‘豆友租房’，有小程序，网页端也有帖子。但无奈，提前看好几个并约好时间看房，但都被告知已经租给别人了。</p><p>新找了一家5人合租的老小区也已经租出去了四间，无奈下在候机的时候就视频看房，然后给了预定金1000元留住房子。当时心情也是七上八下，不知道这样是否妥当，很有可能被骗。最后还是愿意相信一次，交了预定金，来深圳第二天就约了看房。不过，担心的事情也没有发生，看了房ok了就签了合同。</p><img src="https://pic.rmb.bdstatic.com/bjh/9226a587a0c968c17b5fff5d043d4854.jpeg@s_0,w_2000" alt="新房" style="zoom:25%;" /><h3 id="入职">入职</h3><p>入职前是很紧张的，不知道这个组的人怎么样，在做什么，我又是否能胜任？但我又对自己有一丝自信，感觉不管要我做什么都能够出色完成，毕竟‘面试造火箭，工作拧螺丝’也不是没有道理。</p><p>第一天 leader 说有事便叫 mentor 指引我一下，然而我都领完工卡了 mentor 迟迟没有回应，于是靠自己各路问人找到了自己的工位，由另一位几乎和我同名的 elvis 指引下完成了电脑的配置。第一次见到 elvis 的印象是高大 威猛 严肃，后面接触久了发现也是挺可爱的一个人，还有他的迷之口音也很喜感。</p><img src="https://pic.rmb.bdstatic.com/bjh/e930f975314d35e4279358603092cda1.jpeg@s_0,w_2000" alt="工位" style="zoom:25%;" /><p>到了11点过 mentor 终于赶来了，见到他第一眼的感觉是，我 mentor 怎么这么帅啊，心中不知道为啥暗自窃喜。互相认识后， mentor 便带我进行‘新人惯例’的打招呼环节，把我们这半边的同事挨个找了一遍，重复着那略显尴尬的介绍，‘这是 alvis ，对，不是我们组原来的 elvis ，第一个字母是a而不是e…’。我面带微笑地走完了整个流程，当然是一个人都没认识。</p><p>中午 leader 找了一家馆子吃饭，我也第一次知道了 leader 所带的整个大组有哪些人，感觉大家也都很腼腆不爱说话，但都挺友好的。</p><h3 id="适应">适应</h3><p>在迅速解决几个 mentor 给的bug单后，给 mentor 留下了我基础很扎实的印象，我也渐渐适应了这里的环境，变成了一个‘老油条’。每天中午，晚上和组员组队去食堂吃饭，每次找空位找半天让我梦回初中时刻。也慢慢知道了团队里每个人在做啥，周会时也不会听不懂他们在聊什么了。虽然每天下班都会比较晚，有时和 mentor 聊一聊就更晚了，但就这样的生活每天还是很开心，压迫感不是很强。唯一有点遗憾的是没有混迹到他们健身的那伙人里去，主要还是太羞涩，不好意思一起去练。</p><h3 id="收获">收获</h3><p>这次实习的收获主要都是从优秀的 mentor 身上学来的</p><p>一个是沟通，职场小技巧方面</p><ol><li><p><a href="https://blog.xhyh.tech/talk/question-and-answer/">如何高效提问与回答</a>，专门写了一篇讲这件事</p></li><li><p>每次和外部的人沟通，mentor 都会提醒我哪里说得不够好，应该补充一些哪些内容。</p></li><li><p>印象最深的还是如何拉群解决问题，如何甩锅给另一个部门</p></li><li><p>印象深刻的升职小技巧的话，‘如何让 leader 省心’</p></li></ol><p>另一个是技术方面，虽然在实际的技术层面学到的东西不多，但有很多思维上的收获</p><ol><li><p>任何东西不要浮于表面，底层实际原理没有想象中的那么晦涩，一定是已有知识的组合</p></li><li><p>在接触到一个新东西前，已经可以通过自己的知识积累去猜测它是怎么做到的，去了解这个东西只是来验证自己的猜想</p></li><li><p>做东西之前不要只想着当前的需求，而是更加通用化的去考虑</p></li></ol><p>每次遇到卡住的问题时，只要和mentor聊一聊，似乎又又有了新思路</p><h3 id="灾难">灾难</h3><p>顺利的实习有时候也没有那么顺利，由于自己对oc代码不熟悉，缺乏对保护代码安全的严重性的认知，导致灰度后成为了top2 crash。为了赶上合流进度，大晚上了还得找人一个个做代码的Review，企业微信上一般还不会回，得一个人一个人地打电话。最终搞到了2点过才回去。</p><p>不过有这段经历也挺开心的，至少经历过这个，实习算没白来，对自己来说也是一种挑战。</p><h3 id="机缘">机缘</h3><p>实习快要结束的前一周，收获了意外的惊喜</p><p>起因是准备完答辩ppt没事干，开始看别人写的答辩ppt，然后就看到一个技术大佬说写了一篇深入源码解读XXX的博客，那我就很好奇了啊，去搜了搜发现没这篇文章啊，正准备放弃的时候，突然他的博客又出现在了我的眼前。</p><p>然后被他的博客内容给吸引住了，不是他的技术博客，而是他各种8000字的内心活动和独特的思想，第一次见到有人将自己的思想如此暴露在互联网上，而他很多内容我都感觉自己在照镜子一样，和他非常相似，而他又比我更加高级。</p><p>终于忍不住，主动加了他的QQ，后面聊天起来就很有趣了，他说话和机关枪一样，我插不上一句嘴，每次这种场景我都忍不住笑。</p><p>其实对我而言，他的意义并不在于他思想或者技术有多厉害，而是他的存在给我照明了未来的方向，唤醒了我内心封藏已久的东西。有时候，只有有了标杆，才知道自己这么久一直是有问题的。说实话，这篇文章也是因为他才诞生出来的。</p><h3 id="答辩">答辩</h3><p>最后两周时间，或者说最后三周时间已经几乎没有任何技术产出了。首先今年新增了CR代码规范考核的环节，mentor 明智地给我安排了单独的一个任务来应对代码考核，这样不会受到手q一坨屎一样的代码的影响，来来回回修改了好几次，最终结果也很棒，拿到了罕见的S级</p><p>CR考核应对完就开始准备答辩ppt了，一开始写了一个8页的ppt，时间也严格控制在6-8分钟，然后 leader 看了后直说不行，内容不够完整。我只好找 mentor 讨论，最终把要展示的细节问题一一落地，完成后ppt增加到了30页，这个要6-8分分钟讲完有点悬，然而真正答辩那天我居然刚好8分钟就飞速讲完了。</p><p>本来一开始还觉得很不能理解，当时说的就是 leader 和总监还有另一个熟人当答辩的评委，但 leader 对ppt内容却十分严苛，我也没啥好说的，也就认真做。最终意外情况是临时调换了一下答辩的组，换了一群完全不认识的评委，但其实准备太详细也不太好，显然他们对我做的内容不太感兴趣，感受不到评委对我工作的肯定，所以答辩完之后还有一丝失落。</p><h3 id="离别">离别</h3><p>很快，到了离别的时候了，其实和组里人的感情也没有那么深，平时也交流不多，但还是会有一丝伤感。可能更多的是对生活环境的不舍，好吃的食堂，公司的环境，一个人的房间…</p><p>总监和 leader 总是说有时间就尽快过来实习，我也满口答应，但未来的事谁又说得准呢，不确定要不要继续留在这个团队， 对未来的方向也很迷茫。</p><p>不过，生活还在继续，这段美好的实习经历就此别过，又是新的一段旅途…</p><img src="https://pic.rmb.bdstatic.com/bjh/937aa7735b16790494d8f5893822f581.jpeg@s_0,w_1242" alt="腾讯" style="zoom:25%;" /><br><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/talk/">talk</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/summary/">summary</category>
      
      <category domain="https://blog.xhyh.tech/tags/internship/">internship</category>
      
      
      <comments>https://blog.xhyh.tech/talk/internship-tencent/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何高效的提问与回答</title>
      <link>https://blog.xhyh.tech/talk/question-and-answer/</link>
      <guid>https://blog.xhyh.tech/talk/question-and-answer/</guid>
      <pubDate>Sun, 09 Aug 2020 08:31:31 GMT</pubDate>
      
      <description>&lt;p&gt;工作一段时间后, 越发觉得会高效沟通是一个必备技能, 但发现身边不够有经验的人很多, 本篇就来讲述如何高效的提问与回答&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>工作一段时间后, 越发觉得会高效沟通是一个必备技能, 但发现身边不够有经验的人很多, 本篇就来讲述如何高效的提问与回答</p><span id="more"></span><h3 id="提问">提问</h3><div class="success"><p>90%的问题, 想清楚如何提问前, 就找到了答案</p></div><h4 id="好的模式">好的模式</h4><blockquote><p>情况允许下, 尽量让回答者做<strong>选择题</strong>而不是填空题</p></blockquote><ol><li>描述你的目的, 目标或需求<blockquote><p>有助于发现你是否南辕北辙</p></blockquote></li><li>描述你的想法, 思路或自己对它的看法, 认知<blockquote><p>有助于对某些概念达成共识, 或提前发现思路错误</p></blockquote></li><li>描述你的背景, 已经成功做了什么, 网上查了什么<blockquote><p>有助于回答者直击问题, 而不是重头讲起</p></blockquote></li><li>描述遇到的问题, 报错信息, 与自己期望的矛盾点<blockquote><p>有助于回答者精确分析问题, 而不是胡乱猜测</p></blockquote></li></ol><h4 id="禁止的做法">禁止的做法</h4><ul><li><p>“在不在?” / “可以请教一个问题吗?”</p></li><li><p>“xxx是什么?” / “怎么才能xxx?” / “xxx怎么做?”</p></li><li><p>“我的XXX坏了/不工作了/出问题了, 怎么办?”</p></li></ul><h4 id="实际例子">实际例子</h4><p><strong>不好的提问:</strong>  页缓存和内核缓冲区是一个概念吗？</p><p>改进:</p><ol><li><p>加上目标: 想弄清楚内核缓冲区是用来干嘛的</p></li><li><p>加上自己的看法: 我理解的页缓存: XXX, 我理解的内核缓冲区: XXX</p></li><li><p>加上自己的背景: 这个问题是从XXX中而来的, 我现在分析得出的结论是: XXX</p></li><li><p>加上自己的问题: 有点混淆概念, 不知道内核缓冲区存在的意义</p></li></ol><h3 id="回答">回答</h3><h4 id="金字塔原理">金字塔原理</h4><ol><li><p>首先说结论</p></li><li><p>若结论不同意, 则将得出结论的论据拆分成最多3个小点</p></li><li><p>递归确认是否同意, 直到解决所有点</p></li></ol><h4 id="不好的做法">不好的做法</h4><ol><li><p>答非所问</p><blockquote><p>问: 什么是5G? (提问不规范)<br>答: 基站多, 速度快就是5G (回答成了5G的优点)</p></blockquote></li><li><p>阐述过多</p><blockquote><p>问: 什么是5G? (提问不规范)<br>答: 说到5G, 还要从1G, 2G, 3G…说起 (可能对方已经知道了这些)<br></p></blockquote></li></ol><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/talk/">talk</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/summary/">summary</category>
      
      <category domain="https://blog.xhyh.tech/tags/social/">social</category>
      
      
      <comments>https://blog.xhyh.tech/talk/question-and-answer/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>理解内存映射和 mmap</title>
      <link>https://blog.xhyh.tech/study/memory-mapping/</link>
      <guid>https://blog.xhyh.tech/study/memory-mapping/</guid>
      <pubDate>Sun, 02 Aug 2020 04:45:55 GMT</pubDate>
      
      <description>&lt;p&gt;以前总是对mmap的作用很迷惑, 特别是在用户态和内核态概念引入之后就更加疑惑, 为什么mmap可以做到零拷贝?本篇主要是梳理虚拟内存, 内存, 磁盘以及mmap之间的关系&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>以前总是对mmap的作用很迷惑, 特别是在用户态和内核态概念引入之后就更加疑惑, 为什么mmap可以做到零拷贝?本篇主要是梳理虚拟内存, 内存, 磁盘以及mmap之间的关系</p><span id="more"></span><h3 id="什么是mmap">什么是mmap</h3><p>先来看<a href="https://en.wikipedia.org/wiki/Mmap">维基百科</a>的解释</p><blockquote><p>mmap是POSIX兼容的Unix系统调用, 它将文件或设备映射到内存中.<br>这是一种内存映射文件I / O的方法, 它实现了按需分页, 因为文件内容不直接从磁盘读取, 并且最初根本不使用物理RAM</p></blockquote><p>翻译得好听一点就是:</p><ol><li>是一个系统调用</li><li>可以将内存和文件映射</li><li>不直接从磁盘读取文件内容, 最初也不占用内存</li></ol><p>要理解这几条概念首先得知道虚拟内存和分页技术</p><h4 id="虚拟内存">虚拟内存</h4><div class="info"><p>具体虚拟内存为什么存在, 解决了哪些问题, 有什么优点可以单开一章来讲, 这里只讲一些便于理解mmap的东西</p></div><p>理论上讲, 虚拟内存就是存储在<strong>磁盘</strong>上的连续N个字节, 而物理内存则是这些内容的缓存</p><p><img src="https://pic.rmb.bdstatic.com/bjh/2bfa5b6707d571d59bf0a8b26e5f62a8.png" alt="virtual-memory"></p><p>如果以1个字节为单位, 那么每次从磁盘载入进物理内存的效率会非常低, 于是虚拟内存以页为单位存储, 一个页通常是4kb</p><p>那操作系统是如何知道哪些内容被缓存了, 哪些还在磁盘上呢?</p><p>在物理内存里会给每个进程维护一张页表, 当进程使用虚拟地址进行访问内存时, 查页表可知这个页是否已经被加载到物理内存里了</p><p><img src="https://pic.rmb.bdstatic.com/bjh/05ff3794951778d5be6722d682d3865b.png" alt="page-table"></p><h4 id="内存映射">内存映射</h4><p>虚拟内存里面的内容究竟是什么呢?</p><p>在虚拟内存初始化的时候, 有两种途径</p><ol><li>映射存在磁盘上的普通文件(如可执行的二进制文件)</li><li>映射匿名文件(加载进物理内存时初始化全为0)</li></ol><p>虚拟内存初始化的过程, 就叫做内存映射</p><p>通过理解以上两点, 可以解释mmap的概念了</p><ol><li>mmap就是做内存映射的一个系统调用</li><li>虚拟内存是存在磁盘上的, 所以内存映射后初始不占据物理内存, 按需从磁盘载入进物理内存</li></ol><h3 id="怎么用mmap">怎么用mmap</h3><h4 id="操作系统中内存映射使用的场景">操作系统中内存映射使用的场景</h4><ol><li><p>加载可执行程序</p><p>如果不做内存映射的话, 需要先把可执行程序全部读入物理内存中, 再进行命令执行</p><p>这显然是十分低效且不可行的做法, 如果可执行程序比物理内存还大, 运行都无法成功</p><p>采用内存映射, 首先先把可执行程序代码段的内容映射到虚拟内存中, cpu执行指令时发现有缺页错误, 再从磁盘中载入到物理内存里来</p></li><li><p>共享数据</p><p>很多程序都会使用同样的系统共享库, 这些共享库不需要复制多份, 通过内存映射的方式可以使用同一份磁盘上的内容</p><p><img src="https://pic.rmb.bdstatic.com/bjh/5fee85e39a785c251584487e482390ea.png" alt="share-object"></p></li></ol><blockquote><p>私有对象可以采用写时复制技术防止原有数据被修改</p></blockquote><h4 id="用户级别内存映射的使用">用户级别内存映射的使用</h4><p>mmap就是内核提供的, 可以像操作系统一样做内存映射的一个系统调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">int</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">int</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>start</strong>: 指定开始的虚拟地址, 0 表示任意挑选一个地址</p><p><strong>len fd offset</strong>: 从fd指定的文件offet位置开始映射len个字节</p><p><strong>prot</strong>: PROT_READ, PROT_WRITE, PROT_EXEC…</p><p><strong>flags</strong>: MAP_ANON, MAP_PRIVATE, MAP_SHARED…</p><p>返回值: 一个虚拟地址指针, 可能不是start指定的(kernel决定真正映射的地址)</p><p><img src="https://pic.rmb.bdstatic.com/bjh/08ae83cd9ea18dfe208774a9ce8b8bda.png" alt="mmap"></p><ol><li><p>读取大文件</p><p>read读取文件流程: read系统调用-&gt;内核将文件内容读取到内核缓冲区-&gt;内核将缓冲区内容拷贝到用户空间</p><p>mmap读取文件流程: mmap系统调用-&gt;内核进行内存映射-&gt;用户使用数据-&gt;发生缺页异常-&gt;从磁盘载入数据</p></li><li><p>进程间通讯</p><p>进程之间的数据本身是无法互通的(虚拟地址空间), 而通过mmap内存映射的方式, 将同一个文件映射到虚拟内存中, 那么对这个文件的修改都是跨进程可见的<br><br></p></li></ol><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/study/">study</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/os/">os</category>
      
      <category domain="https://blog.xhyh.tech/tags/mmap/">mmap</category>
      
      
      <comments>https://blog.xhyh.tech/study/memory-mapping/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>wsl2 下打开 GUI 程序图形窗口</title>
      <link>https://blog.xhyh.tech/tutorial/wsl2-gui/</link>
      <guid>https://blog.xhyh.tech/tutorial/wsl2-gui/</guid>
      <pubDate>Tue, 12 May 2020 09:52:17 GMT</pubDate>
      
      <description>&lt;p&gt;为了能在Windows wsl2 中运行GUI程序, 踩下不少坑, 反复重装了不知多少次Ubuntu, 希望本文能给后来者一些帮助&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>为了能在Windows wsl2 中运行GUI程序, 踩下不少坑, 反复重装了不知多少次Ubuntu, 希望本文能给后来者一些帮助</p><span id="more"></span><p>相关阅读: <a href="https://blog.xhyh.tech/tutorial/windows-wsl2-env/">Windows下使用wsl2打造极致开发环境</a></p><h3 id="前情提示">前情提示</h3><h4 id="解决方案">解决方案</h4><p>默认情况下, wsl2仅是命令行运行模式, 想要实现运行GUI应用, 有两种解决方案</p><p>1 安装Ubuntu桌面库, 启动远程连接服务器, 使用Windows自带的远程桌面连接(RDP) 连接</p><p>2 在Windows中安装<code>X Server</code>, 将GUI窗口信息转发给<code>X Server</code></p><h4 id="坑">坑</h4><p>首先我尝试的是第一种方案, 具体步骤按照<a href="https://dev.to/darksmile92/linux-on-windows-wsl-with-desktop-environment-via-rdp-522g">这篇教程</a>来做</p><p>然而一开始我的Ubuntu版本是20.04, 使用这种方法登陆上Ubuntu后, RDP软件直接闪退</p><p>于是我重装了Ubuntu 18.04, 成功登陆上了Ubuntu桌面, 但在运行GUI程序时卡住, 可能是由于性能不足</p><p>于是开始尝试第二方案, 一开始使用Ubuntu 18.04, 但发现打开4个窗口时, 有三个窗口直接闪退</p><p>最终切换到Ubuntu 20.04, 使用方案二成功</p><h3 id="配置步骤">配置步骤</h3><h4 id="Windows下安装X-Server">Windows下安装X Server</h4><p>这里选择开源免费的<code>VcXsrv</code>, <a href="https://sourceforge.net/projects/vcxsrv/">下载</a>安装即可</p><p>然后默认<code>VcXsrv</code>分辨率有问题, 还需要修改DPI设置</p><p>找到安装目录, 分别对<code>vcxsrv.exe</code>和<code>xlaunch.exe</code>进行设置</p><p><img src="https://pic.rmb.bdstatic.com/25cdd33c6618a26e5d3beb595d5b552c.png" alt="dpi-setting"></p><p>右键-属性-兼容性-更改高DPI设置-勾选替代高DPI缩放</p><h4 id="Ubuntu下配置转发">Ubuntu下配置转发</h4><p>在<code>.profile</code>配置中加入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> WIN_IP=`cat /etc/resolv.conf | grep nameserver | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line"><span class="built_in">export</span> DISPLAY=<span class="string">&quot;<span class="variable">$&#123;WIN_IP&#125;</span>:0.0&quot;</span></span><br><span class="line"><span class="built_in">export</span> LIBGL_ALWAYS_INDIRECT=1</span><br></pre></td></tr></table></figure><h4 id="Windows下启动VcXsrv">Windows下启动VcXsrv</h4><p>运行<code>XLunch</code>, 第一步, 第二步选择默认</p><p>第三步勾选<code>Disable access control</code><br><img src="https://pic.rmb.bdstatic.com/d9dff7c568de947945fce26502d9273a.png" alt="xlunch"></p><h4 id="Ubuntu下运行GUI程序">Ubuntu下运行GUI程序</h4><p>运行程序<br><img src="https://pic.rmb.bdstatic.com/c7d06755de0801d83beb39bbabcf9cc4.png" alt="run"></p><p>可以看到正常打开窗口</p><blockquote><p>若提示gnome-terminal not found 可直接通过sudo apt install gnome-terminal 安装<br></p></blockquote><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/tutorial/">tutorial</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/windows/">windows</category>
      
      <category domain="https://blog.xhyh.tech/tags/wsl2/">wsl2</category>
      
      
      <comments>https://blog.xhyh.tech/tutorial/wsl2-gui/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>汇编入门之 x86 和 x86_64 函数调用对比 --32位篇</title>
      <link>https://blog.xhyh.tech/study/assembly-function-call-32/</link>
      <guid>https://blog.xhyh.tech/study/assembly-function-call-32/</guid>
      <pubDate>Wed, 29 Apr 2020 03:17:29 GMT</pubDate>
      
      <description>&lt;p&gt;上一篇中讲了64位程序函数的调用情况, 这一篇我们来看32位程序的调用规则, 如果还没有看过上一篇的, 先阅读完上篇再读本文&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>上一篇中讲了64位程序函数的调用情况, 这一篇我们来看32位程序的调用规则, 如果还没有看过上一篇的, 先阅读完上篇再读本文</p><span id="more"></span><h3 id="x86程序分析">x86程序分析</h3><blockquote><p>默认gcc编译成64位程序, 加上-m32参数可编译为32位程序</p></blockquote><h4 id="Og优化级别下">-Og优化级别下</h4><p>首先看<code>add</code>函数</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">subl  <span class="number">$60</span>, %esp</span><br><span class="line">/* 栈保护代码</span><br><span class="line">movl  <span class="number">$20</span>, %edx</span><br><span class="line">movl  %gs:(%edx), %eax</span><br><span class="line">movl  %eax, <span class="number">44</span>(%esp)</span><br><span class="line">*/</span><br><span class="line">xorl  %eax, %eax</span><br><span class="line">movl  <span class="number">68</span>(%esp), %eax // a</span><br><span class="line">addl  <span class="number">64</span>(%esp), %eax // b</span><br><span class="line">addl  <span class="number">12</span>(%esp), %eax // array[<span class="number">2</span>]</span><br><span class="line">addl  <span class="number">8</span>(%esp), %eax  // array[<span class="number">1</span>]</span><br><span class="line">/* 栈保护代码</span><br><span class="line">movl  <span class="number">44</span>(%esp), %ecx</span><br><span class="line">xorl  %gs:(%edx), %ecx</span><br><span class="line"><span class="keyword">jne</span>  .L4</span><br><span class="line">*/</span><br><span class="line">addl  <span class="number">$60</span>, %esp</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>可以看出和64位程序差别不大, 只是在获取参数的时候使用了栈上的值而不是寄存器</p><p>再看<code>main</code>函数</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">leal  <span class="number">4</span>(%esp), %ecx</span><br><span class="line">andl  $-<span class="number">16</span>, %esp</span><br><span class="line">pushl -<span class="number">4</span>(%ecx)</span><br><span class="line">pushl %ebp</span><br><span class="line">movl  %esp, %ebp</span><br><span class="line">pushl  %esi</span><br><span class="line">pushl  %ebx</span><br><span class="line">pushl  %ecx  </span><br><span class="line"></span><br><span class="line">subl  <span class="number">$36</span>, %esp</span><br><span class="line">xorl  %eax, %eax</span><br><span class="line">movl  <span class="number">$4</span>, -<span class="number">40</span>(%ebp)</span><br><span class="line">movl  <span class="number">$5</span>, -<span class="number">36</span>(%ebp)</span><br><span class="line">movl  <span class="number">$6</span>, -<span class="number">32</span>(%ebp)</span><br><span class="line">pushl <span class="number">$8</span></span><br><span class="line">pushl <span class="number">$7</span></span><br><span class="line"><span class="keyword">call</span>  <span class="keyword">add</span></span><br><span class="line">addl  <span class="number">$12</span>, %esp</span><br><span class="line">pushl %eax</span><br><span class="line">leal  .LC0@GOTOFF(%ebx), %eax</span><br><span class="line">pushl %eax</span><br><span class="line">pushl <span class="number">$1</span></span><br><span class="line"><span class="keyword">call</span>  __printf_chk@PLT</span><br><span class="line">addl  <span class="number">$16</span>, %esp</span><br></pre></td></tr></table></figure><p><code>main</code>函数前面一段多了很多奇怪的指令, <code>ebp</code>这一套上一篇已经说过了, 这里即使开启了优化也保留了<code>ebp</code></p><p>而后面几条<code>pushl</code>保存了几个寄存器的值, 属于<code>Callee Saved</code>, 函数运行结束时会<code>popl</code>还原</p><p>前三条命令有点迷惑, 查了下资料看到了一些解释</p><p><code>leal 4(%esp), %ecx</code> 将<code>main</code>函数第一个参数放入寄存器<code>ecx</code>中, 便于后面访问</p><p><code>andl $-16, %esp</code>    将<code>esp</code>地址与16字节对齐(<code>-16 = 0xfffffff0</code>)</p><p><code>pushl  -4(%ecx)</code>    存储函数的返回地址, 暂不知道作用</p><p>后面调用函数时并没有将参数压入寄存器, 而是使用<code>push</code>命令压栈, 函数调用结束后使用<code>add</code>命令释放, 这点和64位下多参数情况一致</p><h4 id="无优化下">无优化下</h4><p><code>add</code>函数</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">pushl %ebp</span><br><span class="line">movl  %esp, %ebp</span><br><span class="line">subl  <span class="number">$56</span>, %esp</span><br><span class="line">xorl  %eax, %eax</span><br><span class="line">movl  <span class="number">8</span>(%ebp), %edx    // a</span><br><span class="line">movl  <span class="number">12</span>(%ebp), %eax   // b</span><br><span class="line">addl  %eax, %edx</span><br><span class="line">movl  -<span class="number">44</span>(%ebp), %eax  // array[<span class="number">2</span>]</span><br><span class="line">addl  %eax, %edx</span><br><span class="line">movl  -<span class="number">48</span>(%ebp), %eax  // array[<span class="number">1</span>]</span><br><span class="line">addl  %edx, %eax</span><br><span class="line">movl  -<span class="number">12</span>(%ebp), %ecx</span><br><span class="line"><span class="keyword">leave</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>可以看出仅仅是使用了<code>ebp</code></p><p>再看<code>main</code>函数</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">leal  <span class="number">4</span>(%esp), %ecx</span><br><span class="line">andl  $-<span class="number">16</span>, %esp</span><br><span class="line">pushl -<span class="number">4</span>(%ecx)</span><br><span class="line">pushl %ebp</span><br><span class="line">movl  %esp, %ebp</span><br><span class="line">pushl %ebx</span><br><span class="line">pushl %ecx</span><br><span class="line">subl  <span class="number">$32</span>, %esp</span><br><span class="line">xorl  %eax, %eax</span><br><span class="line">movl  <span class="number">$4</span>, -<span class="number">24</span>(%ebp)</span><br><span class="line">movl  <span class="number">$5</span>, -<span class="number">20</span>(%ebp)</span><br><span class="line">movl  <span class="number">$6</span>, -<span class="number">16</span>(%ebp)</span><br><span class="line">movl  <span class="number">$7</span>, -<span class="number">32</span>(%ebp)</span><br><span class="line">movl  <span class="number">$8</span>, -<span class="number">28</span>(%ebp)</span><br><span class="line">subl  <span class="number">$8</span>, %esp</span><br><span class="line">pushl -<span class="number">28</span>(%ebp)</span><br><span class="line">pushl -<span class="number">32</span>(%ebp)</span><br><span class="line"><span class="keyword">call</span>  <span class="keyword">add</span></span><br><span class="line">addl  <span class="number">$16</span>, %esp</span><br><span class="line">subl  <span class="number">$8</span>, %esp</span><br><span class="line">pushl %eax</span><br><span class="line">leal  .LC0@GOTOFF(%ebx), %eax</span><br><span class="line">pushl %eax</span><br><span class="line"><span class="keyword">call</span>  printf@PLT</span><br></pre></td></tr></table></figure><p>可以看到<code>main</code>函数和优化过的没有大的区别, 只是<code>printf</code>并没有被优化</p><h3 id="总结">总结</h3><p>总的分析下来, 64位程序和32位程序差别不大, 仅是参数传递的差异, 而当64位参数过多时, 也会采用32位压栈的方式传参</p><p>而不同优化级别下, 最大的差别就是使用<code>rsp</code>作为函数基地址还是<code>rbp</code>作为函数基地址<br><br></p><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/study/">study</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/assembly/">assembly</category>
      
      <category domain="https://blog.xhyh.tech/tags/os/">os</category>
      
      
      <comments>https://blog.xhyh.tech/study/assembly-function-call-32/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>汇编入门之 x86 和 x86_64 函数调用对比 --64位篇</title>
      <link>https://blog.xhyh.tech/study/assembly-function-call-64/</link>
      <guid>https://blog.xhyh.tech/study/assembly-function-call-64/</guid>
      <pubDate>Tue, 28 Apr 2020 03:19:33 GMT</pubDate>
      
      <description>&lt;p&gt;原来一直对64位程序的汇编函数调用比较熟悉, 32位程序的函数调用总觉得十分复杂. 本文主要对64位程序在不同优化级别下的汇编函数调用实现情况, 后篇再结合32位进行对比分析&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>原来一直对64位程序的汇编函数调用比较熟悉, 32位程序的函数调用总觉得十分复杂. 本文主要对64位程序在不同优化级别下的汇编函数调用实现情况, 后篇再结合32位进行对比分析</p><span id="more"></span><h3 id="说明">说明</h3><h4 id="汇编格式">汇编格式</h4><p>如果对汇编指令还不熟悉可以看<a href="https://blog.xhyh.tech/study/assembly-instructions/">上一篇</a>文章, 本文还是采用<code>AT&amp;T</code>汇编格式</p><h4 id="优化级别">优化级别</h4><p>在编译时, 可以指定代码的优化级别, 大致优化级别有如下几个</p><ul><li>-O (相当于 -O1)</li><li>-O0 (不优化, 默认级别)</li><li>-O1 (不影响编译速度的前提下，尽量采用一些优化算法降低代码大小和可执行代码的运行速度)</li><li>-O2 (牺牲部分编译速度, 优化更多)</li><li>-O3 (采取很多向量化算法，提高代码的并行执行程度)</li><li>-Ofast (不会严格遵循语言标准, 优化更多)</li><li>-Og (提供合理的优化水平，同时产生较好的可调试信息)</li><li>-Os (尽量降低目标代码的大小)</li></ul><div class="warning"><p>如果优化级别太高会出现和源代码完全不符的情况, 如函数调用会被优化掉, 出现汇编中没有调用函数的现象</p></div><p>本文主要分析不优化和<code>-Og</code>两种情况</p><h4 id="源代码">源代码</h4><p>为了简便, 下面分析将采用以下源代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">return</span> a + b  + <span class="built_in">array</span>[<span class="number">2</span>] + <span class="built_in">array</span>[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">7</span>, b = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum: %d\n&quot;</span>, add(a, b));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="x86-64程序分析">x86_64程序分析</h3><h4 id="Og优化级别下">-Og优化级别下</h4><p>首先看<code>add</code>函数的汇编代码(已省去无关指令)</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">subq <span class="number">$56</span>, %rsp</span><br><span class="line">/* 栈保护代码</span><br><span class="line">movl  <span class="number">$40</span>, %edx</span><br><span class="line"><span class="keyword">movq</span>  %fs:(%rdx), %rax</span><br><span class="line"><span class="keyword">movq</span>  %rax, <span class="number">40</span>(%rsp)</span><br><span class="line">*/</span><br><span class="line">xorl  %eax, %eax</span><br><span class="line">addl  %esi, %edi      // a + b</span><br><span class="line">addl  <span class="number">8</span>(%rsp), %edi   // array[<span class="number">2</span>]</span><br><span class="line">movl  %edi, %eax</span><br><span class="line">addl  <span class="number">4</span>(%rsp), %eax   // array[<span class="number">1</span>]</span><br><span class="line">/* 栈保护代码</span><br><span class="line"><span class="keyword">movq</span>  <span class="number">40</span>(%rsp), %rcx</span><br><span class="line">xorq  %fs:(%rdx), %rcx</span><br><span class="line"><span class="keyword">jne</span>  .L4</span><br><span class="line">*/</span><br><span class="line">addq  <span class="number">$56</span>, %rsp</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到函数中存在栈保护代码, 这里暂且不说, 与函数调用关系不大, 后面的代码中将省略</p></blockquote><p>首先看出程序会计算出<code>add</code>函数内需要的栈空间, 这里我们开了长度为10的<code>int</code>数组, 需要40字节, 栈保护需要8字节,<br>在使用<code>call</code>调用函数时已经将返回地址8字节压入栈中, 为了使栈内存和16字节对齐, 所以第一步将栈顶指针下移了56字节(56+8 是16的倍数)</p><p><code>rsp + 40</code>的位置用于存放栈保护内容, 而<code>rsp</code>, <code>rsp + 4</code> 则依次存放数组元素<code>array[0]</code>, <code>array[1]</code></p><p><code>eax</code>寄存器作为返回值, 首先通过<code>xor</code>置0</p><p>函数的参数依次存放在<code>edi</code>, <code>esi</code> 寄存器中, 使用<code>add</code>指令累加</p><p>最后将栈指针上移56字节, 回到调用函数前的状态</p><p>再看<code>main</code>函数</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">pushq  %rbx</span><br><span class="line">subq  <span class="number">$32</span>, %rsp</span><br><span class="line">movl  <span class="number">$4</span>, <span class="number">12</span>(%rsp)</span><br><span class="line">movl  <span class="number">$5</span>, <span class="number">16</span>(%rsp)</span><br><span class="line">movl  <span class="number">$6</span>, <span class="number">20</span>(%rsp)</span><br><span class="line">movl  <span class="number">$8</span>, %esi</span><br><span class="line">movl  <span class="number">$7</span>, %edi</span><br><span class="line"><span class="keyword">call</span>  <span class="keyword">add</span></span><br><span class="line">movl  %eax, %edx</span><br><span class="line">leaq  .LC0(%rip), %rsi</span><br><span class="line">movl  <span class="number">$1</span>, %edi</span><br><span class="line">movl  <span class="number">$0</span>, %eax</span><br><span class="line"><span class="keyword">call</span>  __printf_chk@PLT</span><br></pre></td></tr></table></figure><p>除了一开始在栈上保存了<code>rbx</code>以外, 其它步骤基本和<code>add</code>函数一致, 也可以看到函数传参的过程(<code>mov</code>到相应寄存器)</p><blockquote><p>注意这里编译器自动优化, 将printf转换成了更安全的__printf_chk(int flag, const char * format)函数, 所以会多一个参数flag</p></blockquote><h4 id="无优化下">无优化下</h4><p>首先还是先看<code>add</code>函数</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">pushq %rbp</span><br><span class="line"><span class="keyword">movq</span>  %rsp, %rbp</span><br><span class="line">subq  <span class="number">$64</span>, %rsp</span><br><span class="line">movl  %edi, -<span class="number">52</span>(%rbp)</span><br><span class="line">movl  %esi, -<span class="number">56</span>(%rbp)</span><br><span class="line">/* 栈保护</span><br><span class="line"><span class="keyword">movq</span>  %fs:<span class="number">40</span>, %rax</span><br><span class="line"><span class="keyword">movq</span>  %rax, -<span class="number">8</span>(%rbp)</span><br><span class="line">*/</span><br><span class="line">xorl  %eax, %eax</span><br><span class="line">movl  -<span class="number">52</span>(%rbp), %edx</span><br><span class="line">movl  -<span class="number">56</span>(%rbp), %eax</span><br><span class="line">addl  %eax, %edx</span><br><span class="line">movl  -<span class="number">40</span>(%rbp), %eax</span><br><span class="line">addl  %eax, %edx</span><br><span class="line">movl  -<span class="number">44</span>(%rbp), %eax</span><br><span class="line">addl  %edx, %eax</span><br><span class="line">/* 栈保护</span><br><span class="line"><span class="keyword">movq</span>  -<span class="number">8</span>(%rbp), %rcx</span><br><span class="line">xorq  %fs:<span class="number">40</span>, %rcx</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">leave</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>与优化过的代码相比, 最大的变化就是使用了<code>rbp</code>寄存器</p><p><code>rbp</code>存储当前函数的基地址, 一个正在执行的函数A, <code>rsp</code>是 A 的栈顶, <code>rbp</code> 是 A 的栈底<br><img src="https://pic.rmb.bdstatic.com/d54c105690f8ff541982deae78df5457.png" alt="stack-frame"></p><p>函数调用规定了被调用者需存储调用者的<code>rbp</code>信息(Callee Saved), 并且在函数执行结束时恢复</p><p>于是, 使用<code>rbp</code>这一套的模板大概如下</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">pushq %rbp // 存储调用者的<span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">movq</span>  %rsp, %rbp // 将<span class="built_in">rbp</span>设置为当前函数的基地址</span><br><span class="line">subq  <span class="number">$64</span>, %rsp // 为局部变量预留空间</span><br><span class="line"></span><br><span class="line">... // 使用<span class="built_in">rbp</span>作为内存寻址的基地址</span><br><span class="line"></span><br><span class="line"><span class="keyword">leave</span> // <span class="keyword">mov</span> %rbp, %rsp 和 <span class="keyword">pop</span> %rbp 指令的结合</span><br></pre></td></tr></table></figure><blockquote><p>可以看到, 尽管使用rbp寻址, 但仍有subq $64, %rsp操作, 这是为了避免在调用函数时可能的push操作造成和局部变量数据冲突</p></blockquote><h4 id="多参数的情况">多参数的情况</h4><p>在64位程序中, 函数的参数会依次存在<code>%rdi, %rsi, %rdx, %rcx, %r8, %r9</code>, 这6个寄存器中, 如果参数多于6个怎么处理呢? 下面看一个例子</p><p>修改<code>add</code>函数接收7个参数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> f, <span class="keyword">int</span> g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d + e + f + g + <span class="built_in">array</span>[<span class="number">2</span>] + <span class="built_in">array</span>[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码为(-Og优化)</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">add</span> 函数</span><br><span class="line">subq  <span class="number">$56</span>, %rsp</span><br><span class="line">addl  %esi, %edi //a + b</span><br><span class="line">addl  %edx, %edi // c</span><br><span class="line">addl  %ecx, %edi // d</span><br><span class="line">addl  %r8d, %edi // e</span><br><span class="line">addl  %r9d, %edi // f</span><br><span class="line">movl  %edi, %eax  </span><br><span class="line">addl  <span class="number">64</span>(%rsp), %eax // g</span><br><span class="line">addl  <span class="number">8</span>(%rsp), %eax // array[<span class="number">1</span>]</span><br><span class="line">addl  <span class="number">4</span>(%rsp), %eax // array[<span class="number">0</span>]</span><br><span class="line">addq  <span class="number">$56</span>, %rsp</span><br><span class="line"></span><br><span class="line">// main 函数</span><br><span class="line">pushq <span class="number">$0</span>       // g</span><br><span class="line">movl  <span class="number">$0</span>, %r9d // f</span><br><span class="line">movl  <span class="number">$0</span>, %r8d // e</span><br><span class="line">movl  <span class="number">$0</span>, %ecx // d</span><br><span class="line">movl  <span class="number">$0</span>, %edx // c</span><br><span class="line">movl  <span class="number">$8</span>, %esi // b</span><br><span class="line">movl  <span class="number">$7</span>, %edi // a</span><br><span class="line"><span class="keyword">call</span>  <span class="keyword">add</span></span><br><span class="line">addq  <span class="number">$16</span>, %rsp</span><br></pre></td></tr></table></figure><p>可以看到, 在main函数中通过<code>push</code>操作将第7个参数压栈, 调用完成后通过<code>add</code>释放栈空间<br>这也是上面说的为什么即使有<code>rbp</code>作为基地址, 仍然要移动<code>rsp</code>的原因</p></br><p>本文大致讲了两种函数调用的方式, 可以看出, 仅使用<code>rsp</code>代码会简洁不少, 而<code>rbp</code>方式仅仅是方便于调试, 所以在开了优化的情况下, 一般会被编译为<code>rsp</code>方式</p><p>下一篇将讲述32位程序的情况, 并与64位程序做一个对比总结<br><br></p><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/study/">study</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/assembly/">assembly</category>
      
      <category domain="https://blog.xhyh.tech/tags/os/">os</category>
      
      
      <comments>https://blog.xhyh.tech/study/assembly-function-call-64/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MPV 视频播放器配置与插件优化</title>
      <link>https://blog.xhyh.tech/tutorial/mpv-config/</link>
      <guid>https://blog.xhyh.tech/tutorial/mpv-config/</guid>
      <pubDate>Mon, 27 Apr 2020 01:36:19 GMT</pubDate>
      
      <description>&lt;p&gt;原来在Windows下一直用potplayer作为视频播放器, 也没发现什么大问题, 无广告, 支持格式全. 然而最近在倍速播放视频时声音老是出问题, 便搜寻到了一款更简洁的播放器MPV, 也是因为过于简洁, 所以需要配置插件做优化&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>原来在Windows下一直用potplayer作为视频播放器, 也没发现什么大问题, 无广告, 支持格式全. 然而最近在倍速播放视频时声音老是出问题, 便搜寻到了一款更简洁的播放器MPV, 也是因为过于简洁, 所以需要配置插件做优化</p><span id="more"></span><h4 id="MPV安装">MPV安装</h4><p>官方没有提供直接的安装包, 但推荐了一系列的<a href="https://mpv.io/installation/">第三方编译包</a>, 这里我选择Windows平台的<a href="https://sourceforge.net/projects/mpv-player-windows/files/">安装包</a></p><p>下载后直接解压到一个喜欢的目录, 运行目录下的<code>installer</code>文件下中<code>mpv-install.bat</code> 文件可将mpv注册到注册表</p><p>最后将mpv设置成默认的视频播放软件</p><h4 id="MPV配置">MPV配置</h4><p>在mpv安装目录下新建一个<code>portable_config</code>文件夹方便管理配置和插件, 新建配置文件<code>mpv.conf</code></p><p>这里贴一个我在网上找的<a href="https://objectstorage.ap-tokyo-1.oraclecloud.com/n/nrnfoiwu5i48/b/anan/o/mpv.conf">配置</a></p><p>快捷键这里用官方默认的, 不做修改, 可在<a href="https://mpv.io/manual/master/#keyboard-control">官网文档</a>查看</p><h4 id="插件配置">插件配置</h4><p>官方记录了很多第三方插件, 如果有需要可以去<a href="https://github.com/mpv-player/mpv/wiki/User-Scripts">查看</a></p><p>这里我的需求有两个, 一个是可以选择播放列表, 一个是可以查看播放历史</p><p>播放列表使用的插件是<a href="https://github.com/jonniek/mpv-playlistmanager">playlistmanager</a>, 只需下载其中的<code>playlistmanager.conf</code>, <code>playlistmanager.lua</code> 分别放入<code>portable_config</code>中的<code>script-opts</code>文件夹和<code>scripts</code>文件夹</p><blockquote><p>这里默认的配置字体有点大, 可以修改style_ass_tags配置项调整大小</p></blockquote><p>播放历史使用的插件是<a href="https://github.com/hacel/mpv-scripts">recent</a>, 只需下载其中的<code>recent.lua</code>放入<code>scripts</code>文件夹即可</p><h4 id="播放文件夹">播放文件夹</h4><p>很多时候都需要按照文件夹来播放, 自动生成播放列表, 配合播放列表插件使用</p><p>这里提供一个注册表<a href="https://objectstorage.ap-tokyo-1.oraclecloud.com/n/nrnfoiwu5i48/b/anan/o/mpv.reg">配置</a>, 修改为自己的mpv安装路径, 运行即可<br><br></p><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/tutorial/">tutorial</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/mpv/">mpv</category>
      
      <category domain="https://blog.xhyh.tech/tags/software/">software</category>
      
      
      <comments>https://blog.xhyh.tech/tutorial/mpv-config/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>汇编入门之汇编指令详解</title>
      <link>https://blog.xhyh.tech/study/assembly-instructions/</link>
      <guid>https://blog.xhyh.tech/study/assembly-instructions/</guid>
      <pubDate>Sun, 26 Apr 2020 03:18:26 GMT</pubDate>
      
      <description>&lt;p&gt;最近在深入学习操作系统, 少不了和汇编代码打交道, 尽管原来对汇编指令有所了解, 但实际看到一条指令还是模凌两可. 本文对常用汇编指令进行一个总结, 同时区分几个易混的指令&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近在深入学习操作系统, 少不了和汇编代码打交道, 尽管原来对汇编指令有所了解, 但实际看到一条指令还是模凌两可. 本文对常用汇编指令进行一个总结, 同时区分几个易混的指令</p><span id="more"></span><h3 id="汇编格式说明">汇编格式说明</h3><p>一般来说, 在<code>Linux</code>下使用<code>GCC</code>生成的汇编代码会使用<code>AT&amp;T/UNIX</code>汇编语法, 而使用<code>IDA</code>, <code>pwndbg</code>, <code>gef</code>反编译出来的代码会使用<code>Intel</code>汇编语法</p><p>下面大致讲一下两者语法的不同, 后文将使用<code>AT&amp;T</code>汇编格式</p><ol><li><p>操作数顺序不同</p> <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">Op-code src dst //<span class="meta">AT</span>&amp;T语法</span><br><span class="line">Op-code dst src //Intel语法</span><br></pre></td></tr></table></figure></li><li><p>寄存器, 立即数的使用</p> <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">movl  <span class="number">$0</span>xff,%ebx //<span class="meta">AT</span>&amp;T语法</span><br><span class="line"><span class="keyword">mov</span>   <span class="built_in">ebx</span>,<span class="number">0ffh</span>   //Intel语法</span><br></pre></td></tr></table></figure></li><li><p>操作数大小</p> <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">movb  (%rbp), %al //<span class="meta">AT</span>&amp;T语法</span><br><span class="line"><span class="keyword">mov</span>   <span class="built_in">al</span>, <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">rbp</span>   //Intel语法</span><br></pre></td></tr></table></figure><blockquote><p>movb, movw, movl, movq 分别代表操作1, 2, 4, 8字节, 若仅是mov, 则根据应用是32位还是64位决定是movl还是movq</p></blockquote></li><li><p>内存寻址</p> <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">movl -<span class="number">8</span>(%ebp, %edx, <span class="number">4</span>), %eax //<span class="meta">AT</span>&amp;T语法</span><br><span class="line"><span class="keyword">mov</span>  <span class="built_in">eax</span>, [%ebp + %edx * <span class="number">4</span> - <span class="number">8h</span>] //Intel语法</span><br></pre></td></tr></table></figure></li></ol><h3 id="常见指令">常见指令</h3><h4 id="mov指令">mov指令</h4><p>mov作为最常用的指令, 用法非常灵活</p><p>语法</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> &lt;reg&gt;, &lt;reg&gt; // 寄存器的值到寄存器的值</span><br><span class="line"><span class="keyword">mov</span> &lt;reg&gt;, &lt;mem&gt; // 寄存器的值到寄存器指针指向的内存(通过加括号的方式)</span><br><span class="line"><span class="keyword">mov</span> &lt;mem&gt;, &lt;reg&gt; // 内存到寄存器</span><br><span class="line"><span class="keyword">mov</span> &lt;imm&gt;, &lt;reg&gt; // 立即数到寄存器(立即数前要加$)</span><br><span class="line"><span class="keyword">mov</span> &lt;imm&gt;, &lt;mem&gt; // 立即数到内存</span><br></pre></td></tr></table></figure><blockquote><p>内存寻址方式可采用disp(base, index, scale)的方式, 对表达式整体计算的值作为内存地址 如mov -8(%ebp, %edx, 4), %eax 表示加载 *(ebp + (edx * 4) - 8) 到 eax寄存器</p></blockquote><h4 id="push-pop指令">push / pop指令</h4><p>push可以理解为在mov到esp内存的同时使<code>esp</code>减小(高地址到低地址扩展)<br>pop 可以理解为在mov到esp内存的同时的同时使<code>esp</code>增加</p><p>语法</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">push</span> &lt;reg&gt;</span><br><span class="line"><span class="keyword">push</span> &lt;mem&gt;</span><br><span class="line"><span class="keyword">push</span> &lt;imm&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在64位里push操作8字节的数, 32位只能操作4子节的数</p></blockquote><h4 id="lea-指令">lea 指令</h4><p>lea 可以将内存操作数放入寄存器中<br>lea 虽然用法单一, 但十分灵活, 常用来代替乘法和加法指令</p><p>语法</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lea</span> &lt;mem&gt;, &lt;reg&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这里的mem并不是真的取内存中的值, 而是操作数本身 如lea -8(%ebp, %edx, 4), %eax 表示加载 ebp + (edx * 4) - 8 的值到 eax寄存器</p></blockquote><h4 id="add-sub-指令">add / sub 指令</h4><p>这两个指令比较简单, 就是做加法和减法, 将操作结果存在目的操作数中</p><p>语法</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add</span> &lt;reg&gt;, &lt;reg&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;imm&gt;, &lt;reg&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;imm&gt;, &lt;mem&gt;</span><br></pre></td></tr></table></figure><h4 id="inc-dec-指令">inc / dec 指令</h4><p>基本和add / sub一致, 但只能加减1</p><p>语法</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inc</span> &lt;reg&gt;</span><br><span class="line"><span class="keyword">inc</span> &lt;mem&gt;</span><br></pre></td></tr></table></figure><h4 id="imul-指令">imul 指令</h4><p>乘法指令, 可以有两个操作数或三个操作数, 第三个操作数必须为寄存器</p><p>语法</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">imul</span> &lt;reg32&gt;, &lt;reg32&gt;</span><br><span class="line"><span class="keyword">imul</span> &lt;mem&gt;, &lt;reg32&gt;</span><br><span class="line"><span class="keyword">imul</span> &lt;imm&gt;, &lt;reg32&gt;, &lt;reg32&gt;</span><br><span class="line"><span class="keyword">imul</span> &lt;imm&gt;, &lt;mem&gt;, &lt;reg32&gt;</span><br></pre></td></tr></table></figure><h4 id="idiv-指令">idiv 指令</h4><p>除法指令, 需要把被除数放入eax寄存器中, 得到商在eax中, 余数在edx中</p><p>语法</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">idiv</span> &lt;reg&gt;</span><br><span class="line"><span class="keyword">idiv</span> &lt;mem&gt;</span><br></pre></td></tr></table></figure><h4 id="and-or-xor-指令">and / or / xor 指令</h4><p>做与, 或, 异或运算</p><p>语法</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> &lt;reg&gt;, &lt;reg&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;imm&gt;, &lt;reg&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;imm&gt;, &lt;mem&gt;</span><br></pre></td></tr></table></figure><blockquote><p>常使用xor %edx, %edx 将寄存器置0</p></blockquote><h4 id="not-neg-指令">not / neg 指令</h4><p>not 按位取反, neg 按补码取负</p><p>语法</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">not</span> &lt;reg&gt;</span><br><span class="line"><span class="keyword">not</span> &lt;mem&gt;</span><br></pre></td></tr></table></figure><h4 id="shl-shr-sal-sar指令">shl / shr / sal / sar指令</h4><p>逻辑左移/逻辑右移/算数左移/算数右移操作</p><p>语法</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">shl</span> &lt;imm&gt;, &lt;reg&gt;</span><br><span class="line"><span class="keyword">shl</span> &lt;imm&gt;, &lt;mem&gt;</span><br><span class="line"><span class="keyword">shl</span> %cl, &lt;reg&gt;</span><br><span class="line"><span class="keyword">shl</span> %cl, &lt;mem&gt;</span><br></pre></td></tr></table></figure><h4 id="jmp-jcondition-cmp指令">jmp / jcondition /cmp指令</h4><p>跳转到某一标签, 常用语循环语句和判断语句</p><p>语法</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">jmp</span> &lt;label&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">cmp</span> &lt;reg&gt;, &lt;reg&gt;</span><br><span class="line"><span class="keyword">cmp</span> &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line"><span class="keyword">cmp</span> &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line"><span class="keyword">cmp</span> &lt;imm&gt;, &lt;reg&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">je</span>  &lt;label&gt; // 等于时跳转</span><br><span class="line"><span class="keyword">jne</span> &lt;label&gt; // 不等时跳转</span><br><span class="line"><span class="keyword">jz</span>  &lt;label&gt; // <span class="keyword">cmp</span>将两数相减, 为<span class="number">0</span>时跳转</span><br><span class="line"><span class="keyword">jg</span>  &lt;label&gt; // 大于时跳转</span><br><span class="line"><span class="keyword">jge</span> &lt;label&gt; // 大于等于跳转</span><br><span class="line"><span class="keyword">jl</span>  &lt;label&gt; // 小于时跳转</span><br><span class="line"><span class="keyword">jle</span> &lt;label&gt; // 小于等于跳转</span><br></pre></td></tr></table></figure><h4 id="call-ret-指令">call / ret 指令</h4><p>函数调用及函数返回</p><p>语法</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> &lt;label&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><h3 id="常见问题">常见问题</h3><h4 id="mov-和-lea-指令的区别">mov 和 lea 指令的区别</h4><p>在简单操作上两者可以等价</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> %eax, %ebx</span><br><span class="line"></span><br><span class="line"><span class="keyword">lea</span> (%eax), %ebx</span><br></pre></td></tr></table></figure><p>若mov使用了内存寻址, 则mov会取到对应地址的值, 而lea仅操作地址</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> -<span class="number">8</span>(%ebp, %edx, <span class="number">4</span>), %eax</span><br><span class="line"></span><br><span class="line"><span class="keyword">lea</span> -<span class="number">8</span>(%ebp, %edx, <span class="number">4</span>), %eax</span><br></pre></td></tr></table></figure><p>在这种情况下, mov便无法替代lea</p><h4 id="i-为什么不是原子操作">i++为什么不是原子操作</h4><p>尽管add/inc可以直接对内存进行操作, 但实际情况下会先从内存加载到寄存器中, 再对寄存器进行加操作<br><br></p><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/study/">study</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/assembly/">assembly</category>
      
      <category domain="https://blog.xhyh.tech/tags/os/">os</category>
      
      
      <comments>https://blog.xhyh.tech/study/assembly-instructions/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Windows 下使用 wsl2 打造极致开发环境</title>
      <link>https://blog.xhyh.tech/tutorial/windows-wsl2-env/</link>
      <guid>https://blog.xhyh.tech/tutorial/windows-wsl2-env/</guid>
      <pubDate>Tue, 14 Apr 2020 01:09:44 GMT</pubDate>
      
      <description>&lt;p&gt;自Windows Terminal发布后一直用得很爽, 我也一直在关注着另一个’神器’wsl2的到来. Windows 2004 RTM版出来后我便立即重装了系统, 感受到了wsl2的强大. 本文的主要内容就是如何配置wsl2并解决它带来的一些问题&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>自Windows Terminal发布后一直用得很爽, 我也一直在关注着另一个’神器’wsl2的到来. Windows 2004 RTM版出来后我便立即重装了系统, 感受到了wsl2的强大. 本文的主要内容就是如何配置wsl2并解决它带来的一些问题</p><span id="more"></span><h3 id="为什么需要wsl2">为什么需要wsl2</h3><p>如果你是一个开发人员, 一定有以下几个痛点</p><ol><li>安装软件麻烦, c++应该下哪个? python应该下哪个? vscode对应的配置怎么配?</li><li>残缺的<code>Git bash</code>,  <code>wget</code> 命令去哪了?  <code>md5sum</code>在哪?</li><li>巨慢的<code>git clone</code>, ssh怎么不走代理啊? 怎么配置?</li><li>乱码问题, 我使用<code>UTF-8</code>编码, 怎么运行到命令行就乱码?</li></ol><p><code>Windows</code>下还有很多问题就不一一列举了</p><h3 id="wsl2能解决的问题">wsl2能解决的问题</h3><ol><li>真实<code>Linux</code>内核, 带来了完整的<code>Linux</code>体验</li><li>优化后的IO速度, 读写速度快</li><li>内存回收技术, 避免占用过多内存不释放</li><li>自动挂载Windows磁盘, 无缝访问Windows文件</li></ol><h3 id="wsl2安装">wsl2安装</h3><p>具体安装请看<a href="https://docs.microsoft.com/en-us/windows/wsl/wsl2-install">官方文档</a></p><p>大致的步骤是</p><ol><li>打开可选功能的<code>适用于Linux的Windows子系统</code>和<code>虚拟机平台</code></li><li>重启计算机</li><li>在<code>Windows Store</code>中下载<code>Linux</code>发行版, 如<code>Ubuntu</code></li><li>启动<code>Ubuntu</code>, 设置用户名, 密码(此时默认是<code>wsl</code>而不是<code>wsl2</code>)</li><li>在<code>powershell</code>中根据文档切换成<code>wsl2</code></li><li>若提示切换失败, 可能需要手动安装内核, 去<a href="https://docs.microsoft.com/en-us/windows/wsl/wsl2-kernel">官网</a>下载安装</li></ol><h3 id="Windows-Terminal配置">Windows Terminal配置</h3><ol><li>主题配置 这里贴一份我自己的配置, 有需要的可以<a href="https://objectstorage.ap-tokyo-1.oraclecloud.com/n/nrnfoiwu5i48/b/anan/o/settings.json">下载</a>修改<br><img src="https://pic.rmb.bdstatic.com/3a62a32f090a8aed6fb9caa0af0019eb.png" alt="windows-terminal"></li><li>右键-在此文件夹中打开 这个功能需要添加注册表, 有需要可以<a href="https://objectstorage.ap-tokyo-1.oraclecloud.com/n/nrnfoiwu5i48/b/anan/o/right.reg">下载</a>, 运行</li></ol><h3 id="wsl2简单配置">wsl2简单配置</h3><ol><li><p>使用<code>zsh</code>作为默认<code>bash</code>(可选, 这里不做过多介绍)</p></li><li><p>当使用<code>Windows Search</code> 打开<code>Windows Terminal</code>时, 默认进入用户目录<code>~</code></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span> == *<span class="string">&quot;Windows&quot;</span>* ]] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">cd</span> ~</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><blockquote><p>由于我使用了oh-my-zsh, 每次安装会覆盖原有的.zshrc, 所以我的所有关于bash配置都写在~/.profile下, 并在.zshrc中使用source .profile加载, 更多配置可以参考<a href="https://objectstorage.ap-tokyo-1.oraclecloud.com/n/nrnfoiwu5i48/b/anan/o/.profile">.profile文件</a></p></blockquote></li><li><p>配置默认使用<code>vim</code>作为可视化编辑器</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> VISUAL=vim</span><br><span class="line"><span class="built_in">export</span> EDITOR=<span class="string">&quot;<span class="variable">$VISUAL</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="wsl2代理设置">wsl2代理设置</h3><p><code>wsl2</code>采用的网络模式是<code>Nat</code>模式, 在<code>wsl2</code>中如果想使用<code>Windows</code>下的代理会比较麻烦, 不能直接通过<code>localhost</code>访问</p><blockquote><p>但Windows却可以使用localhost访问wsl2中的服务, 很便于程序的调试</p></blockquote><p>首先需要安装<code>proxychains4</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install proxychains4</span><br></pre></td></tr></table></figure><p>复制一份配置文件到用户目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/proxychains4.conf ~/.proxychains.conf</span><br></pre></td></tr></table></figure><p>配置bash设置(.profile中)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到windows ip</span></span><br><span class="line"><span class="built_in">export</span> WIN_IP=`cat /etc/resolv.conf | grep nameserver | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line"><span class="comment"># 删除原有socks5配置</span></span><br><span class="line">sed -i <span class="string">&#x27;/socks5/d&#x27;</span> ~/.proxychains.conf</span><br><span class="line"><span class="comment"># 添加新的socks5配置</span></span><br><span class="line">sed -i <span class="string">&#x27;$a socks5 &#x27;</span><span class="variable">$&#123;WIN_IP&#125;</span><span class="string">&#x27; 7891&#x27;</span> ~/.proxychains.conf</span><br><span class="line"><span class="built_in">alias</span> pc=<span class="string">&#x27;proxychains4 -q -f ~/.proxychains.conf&#x27;</span></span><br><span class="line"><span class="comment"># 在使用sudo时同时使用&#x27;pc&#x27; proxychains的alias</span></span><br><span class="line"><span class="built_in">alias</span> sudo=<span class="string">&#x27;sudo &#x27;</span></span><br></pre></td></tr></table></figure><p>这样每次启动都会寻找正确的ip地址, 并设置好给<code>proxychains4</code></p><h3 id="vscode设置">vscode设置</h3><p>还是由于网络问题, <code>remote server</code>继承了主<code>vscode</code>的配置, 代理会默认被设为<code>127.0.0.1:7890</code>, 会出现无法下载插件, 或无法使用插件等问题</p><p>经过测试, 即使在<code>wsl2</code>设置了<code>http_proxy</code>环境变量也没办法生效(主配置已检测到代理), 需要手动设置才能生效<br><img src="https://pic.rmb.bdstatic.com/ff4e30a30dd6be1ee200ef58054b83e9.png" alt="vscode-config"></p><h3 id="其他配置">其他配置</h3><p>大多数软件都能使用<code>wsl2</code>替代, 如<code>git</code>, <code>c++</code>, <code>python</code>, <code>golang</code>等</p><p>但还是有些依赖图形化的软件只能在<code>Windows</code>下运行, 如<code>IDEA</code>, <code>Android Studio</code>等</p><p>这些软件也依赖于<code>git</code>, 但又不想在<code>Windows</code>又装一个重量级的<code>git bash</code>, 于是我找到两种解决方案, 一种是<code>git</code>映射到<code>wsl2</code>中的<code>git</code>, 第二种是额外下载一个轻量级的<code>git</code>–<a href="https://github.com/git-for-windows/git/releases">MinGit</a></p><p>这里推荐第二种方法, 简单, 最小只有20M左右, 而且无需安装</p><h3 id="坑">坑</h3><p><code>wsl2</code>唯一的缺点是无法自动缩进磁盘空间, 当突然下载大文件后又删除后, 虚拟机占用空间并不会减少, 只会持续扩张. 目前解决办法是磁盘分区, 后续官方应该有更好的解决方法</p><h3 id="总结">总结</h3><p>总得来说, <code>wsl2</code>的体验很不错, 有种在<code>Linux</code>中使用<code>Windows</code>的感觉, 既可以享受<code>Windows</code>众多图形化软件带来的优势, 也可以方便快捷使用<code>Linux</code>做程序开发, 这点就比原生<code>Linux</code>强很多了, 和<code>mac</code>的差距也没那么大了<br><br></p><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/tutorial/">tutorial</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/windows/">windows</category>
      
      <category domain="https://blog.xhyh.tech/tags/wsl2/">wsl2</category>
      
      
      <comments>https://blog.xhyh.tech/tutorial/windows-wsl2-env/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo 主题开发和修改 --实践篇</title>
      <link>https://blog.xhyh.tech/tutorial/hexo-theme-dev/</link>
      <guid>https://blog.xhyh.tech/tutorial/hexo-theme-dev/</guid>
      <pubDate>Mon, 13 Apr 2020 00:32:54 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;a href=&quot;https://blog.xhyh.tech/tutorial/hexo-theme-theory/&quot;&gt;上一篇&lt;/a&gt;中, 我们了解了Hexo主题的目录结构和基本的语法知识, 本文主要针对&lt;code&gt;apollo&lt;/code&gt;主题进行开发和修改&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://blog.xhyh.tech/tutorial/hexo-theme-theory/">上一篇</a>中, 我们了解了Hexo主题的目录结构和基本的语法知识, 本文主要针对<code>apollo</code>主题进行开发和修改</p><span id="more"></span><h3 id="布局修改">布局修改</h3><h4 id="部分部局">部分部局</h4><p>为了使布局能够复用, 所以将一个页面拆分成多个模块</p><p><code>head</code> 网页的头部信息, 变量可通过Hexo中配置文件<code>config.xxx</code>获取</p><p><code>nav</code> 导航栏信息, 可通过遍历主题配置<code>each value, key in theme.menu</code>获取</p><p><code>layout</code> 基布局, 包含多个<code>block</code>可以被覆盖</p><p><code>comment</code> 评论布局, 包括了所有支持的评论插件</p><p><code>copyright</code> 底部布局</p><p><code>scripts</code> 页面所需的js</p><h4 id="博客页面">博客页面</h4><p>主页: 继承至<code>layout</code>布局, 包含三大部分</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extends</span> partial/layout</span><br><span class="line"></span><br><span class="line">block container</span><br><span class="line">    include mixins/post</span><br><span class="line">    +posts()</span><br><span class="line"></span><br><span class="line">block pagination</span><br><span class="line">    include mixins/paginator</span><br><span class="line">    +home()</span><br><span class="line"></span><br><span class="line">block copyright</span><br><span class="line">    include partial/copyright</span><br></pre></td></tr></table></figure><p>其中<code>posts()</code>是混入的函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mixin posts()</span><br><span class="line">    ul.home.post-list</span><br><span class="line">        - page.posts.each(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">            li.post-list-item</span><br><span class="line">                article.post-block</span><br><span class="line">                    h2.post-title</span><br><span class="line">                        a.post-title-link(href= url_for(item.path))</span><br><span class="line">                            != item.title</span><br><span class="line">                    +postInfo(item)</span><br><span class="line">                    .post-content</span><br><span class="line">                        != item.excerpt</span><br><span class="line">                    a.read-more(href= url_for(item.path))!= __(<span class="string">&#x27;more&#x27;</span>)</span><br><span class="line">        - &#125;)</span><br><span class="line">mixin postInfo(item)</span><br><span class="line">    .post-info</span><br><span class="line">        != full_date(item.date, <span class="string">&#x27;ll&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (item.tags &amp;&amp; (is_home() || is_post()))</span><br><span class="line">            <span class="keyword">for</span> tag <span class="keyword">in</span> item.tags.toArray()</span><br><span class="line">                a.tag-title(href=url_for(tag.path))</span><br><span class="line">                    != <span class="string">&#x27;#&#x27;</span> + tag.name</span><br></pre></td></tr></table></figure><blockquote><p>如果想修改, 比如给文章加上tag, 就可以自行在<code>postInfo</code>函数中加入对应的标签</p></blockquote><p>文章页: 和<code>index</code>页面基本一样, 但多了标题和描述block的覆盖</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extends</span> partial/layout</span><br><span class="line"></span><br><span class="line">block site_title</span><br><span class="line">    != page.title + <span class="string">&quot; · &quot;</span> + config.title</span><br><span class="line"></span><br><span class="line">block description</span><br><span class="line">    - <span class="keyword">var</span> desc = page.desc || page.title + <span class="string">&#x27; - &#x27;</span> + config.author;</span><br><span class="line">    meta(name=<span class="string">&quot;description&quot;</span>, content=desc)</span><br><span class="line"></span><br><span class="line">block container</span><br><span class="line">    include mixins/post</span><br><span class="line">    +post(page)</span><br><span class="line"></span><br><span class="line">block pagination</span><br><span class="line">    include mixins/paginator</span><br><span class="line">    +post()</span><br><span class="line">    include partial/comment</span><br><span class="line"></span><br><span class="line">block copyright</span><br><span class="line">    include partial/copyright</span><br></pre></td></tr></table></figure><p>自定义页面: 需要在<code>block container</code>中判断页面类型实现不同的内容</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extends</span> partial/layout</span><br><span class="line"></span><br><span class="line">block container</span><br><span class="line">    <span class="keyword">if</span> page.type === <span class="string">&#x27;category&#x27;</span></span><br><span class="line">      .category  </span><br><span class="line">          h2.title</span><br><span class="line">              != page.title</span><br><span class="line">          != list_categories()</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> page.type === <span class="string">&#x27;friends&#x27;</span></span><br><span class="line">      .flink</span><br><span class="line">        <span class="keyword">if</span> site.data.link</span><br><span class="line">           ...</span><br><span class="line">block pagination</span><br><span class="line">    include mixins/paginator</span><br><span class="line">    +home()</span><br><span class="line"></span><br><span class="line">block copyright</span><br><span class="line">    include partial/copyright</span><br></pre></td></tr></table></figure><blockquote><p>我这里使用<code>page.type</code>判断页面类型, 这样需要在对应页面<code>index.md</code>中添加<code>type</code>变量</p></blockquote><h3 id="样式修改">样式修改</h3><h4 id="根样式">根样式</h4><p>定义一个根样式, <code>gulp</code>只编译这个文件, 更方便管理, 其他样式通过<code>@import</code>引入</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;_partial/normalize&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;_partial/base&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;_partial/header&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">&#x27;https://fonts.googleapis.com/css?family=Open+Sans&amp;display=swap&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="部分样式">部分样式</h4><p>根据每个部分布局定义部分样式, 再在根样式中引入</p><p>在命令行中运行<code>gulp</code>命令即可监控样式的更改, 实时编译</p><blockquote><p>在chrome中, 右键-检查想修改的部分, 可快速定位css信息和debug</p></blockquote><h3 id="配置修改">配置修改</h3><p>可根据自身需求在<code>_config</code>文件中进行修改, 可以新增<code>menu</code>菜单或新增变量<br><br></p><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/tutorial/">tutorial</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/blog/">blog</category>
      
      <category domain="https://blog.xhyh.tech/tags/hexo-theme/">hexo-theme</category>
      
      
      <comments>https://blog.xhyh.tech/tutorial/hexo-theme-dev/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo 主题开发和修改 --理论篇</title>
      <link>https://blog.xhyh.tech/tutorial/hexo-theme-theory/</link>
      <guid>https://blog.xhyh.tech/tutorial/hexo-theme-theory/</guid>
      <pubDate>Sat, 11 Apr 2020 03:37:19 GMT</pubDate>
      
      <description>&lt;p&gt;在寻找Hexo主题时, 发现了一款极其简洁的主题&lt;a href=&quot;https://github.com/achjqz/hexo-theme-apollo&quot;&gt;apollo&lt;/a&gt;, 这款主题代码量不多, 视图引擎使用的是&lt;code&gt;pug&lt;/code&gt;(原名&lt;code&gt;jade&lt;/code&gt;), 本文主要讲述进行Hexo主题开发和对主题的理论部分&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>在寻找Hexo主题时, 发现了一款极其简洁的主题<a href="https://github.com/achjqz/hexo-theme-apollo">apollo</a>, 这款主题代码量不多, 视图引擎使用的是<code>pug</code>(原名<code>jade</code>), 本文主要讲述进行Hexo主题开发和对主题的理论部分</p><span id="more"></span><h3 id="主题下载和环境配置">主题下载和环境配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/achjqz/hexo-theme-apollo.git apollo</span><br><span class="line"><span class="built_in">cd</span> apollo</span><br><span class="line">npm install</span><br><span class="line">npm install --global gulp-cli</span><br></pre></td></tr></table></figure><blockquote><p>主题用到的所有依赖包都是gulp相关的, gulp可以使开发者更方便的编写css文件</p></blockquote><h3 id="主题目录结构介绍">主题目录结构介绍</h3><p><img src="https://pic.rmb.bdstatic.com/e5d6dc0330e0dbfb33d4419d968c5a8c.png" alt="catalog"></p><h4 id="docs文件夹">docs文件夹</h4><p>这个文件夹是自己新建的, 存放主题的配置文档说明, 可有可无</p><h4 id="languages文件夹">languages文件夹</h4><p>根据<a href="https://hexo.io/zh-cn/docs/internationalization.html">Hexo官网</a>的说明, 在此文件夹下配置多语言文件,可以让网站以不同语言呈现</p><p>例如, 配置<code>en.yml</code>和<code>zh-Hans.yml</code>文件可以支持英语和中文</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># en.yml</span></span><br><span class="line"><span class="attr">more:</span> <span class="string">...more</span></span><br><span class="line"><span class="comment"># zh-Hans.yml</span></span><br><span class="line"><span class="attr">more:</span> <span class="string">...阅读更多</span></span><br></pre></td></tr></table></figure><p>在模板中, 使用 __ 或 _p 辅助函数, 即可取得翻译后的字符串, 前者用于一般使用；而后者用于复数字符串</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.read-more(href= url_for(item.path))!= __(&#x27;more&#x27;)</span><br></pre></td></tr></table></figure><h4 id="layout文件夹">layout文件夹</h4><p>该文件夹存放的就是博客页面的布局文件, 根据需求, 至少存在<code>index</code>, <code>post</code>, <code>archive</code> 三个页面</p><table><thead><tr><th>模板</th><th>用途</th><th>回退</th></tr></thead><tbody><tr><td>index</td><td>首页</td><td></td></tr><tr><td>post</td><td>文章</td><td>index</td></tr><tr><td>page</td><td>分页</td><td>index</td></tr><tr><td>archive</td><td>归档</td><td>index</td></tr><tr><td>category</td><td>分类归档</td><td>archive</td></tr><tr><td>tag</td><td>标签归档</td><td>archive</td></tr></tbody></table><h4 id="source文件夹">source文件夹</h4><p>该文件夹下主要存放<code>css</code>文件, <code>js</code>文件, 图片资源等</p><h4 id="config-yml文件"><code>_config.yml</code>文件</h4><p>主题配置文件, 其中定义的变量在模版中可通过<code>theme.xxx</code>获取</p><blockquote><p>Hexo博客目录下也有同样的配置文件, 可以覆盖主题中定义的变量</p></blockquote><h4 id="gulpfile-js-文件"><code>gulpfile.js</code> 文件</h4><p>执行<code>gulp</code>命令后执行的脚本, 可以将<code>scss</code>打包成<code>css</code>并监控文件变化, 后文会详细讲解</p><h3 id="布局语法和样式语法">布局语法和样式语法</h3><h4 id="pug语法了解"><code>pug</code>语法了解</h4><ol><li><p>html标签, 注意缩进</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div</span><br><span class="line">    p Hello, world!</span><br><span class="line">    p Hello, pug.</span><br></pre></td></tr></table></figure></li><li><p>定义class或id</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">h1.title Test <span class="class"><span class="keyword">class</span> <span class="title">title</span></span></span><br><span class="line"><span class="class"><span class="title">h1</span>#<span class="title">title</span> <span class="title">Test</span> <span class="title">id</span> <span class="title">title</span></span></span><br></pre></td></tr></table></figure></li><li><p>标签属性, 存放于括号内</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">img#name.class1.class2(src=<span class="string">&quot;/test.png&quot;</span> alt=<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>包含,方便代码复用</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">doctype html</span><br><span class="line">html(lang=<span class="string">&#x27;en&#x27;</span>)</span><br><span class="line">    include _partial/head.pug</span><br></pre></td></tr></table></figure></li><li><p>继承, 方便模块化编写</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//- base.pug</span></span><br><span class="line">html</span><br><span class="line">    head</span><br><span class="line">        block title</span><br><span class="line">    body</span><br><span class="line">        block content</span><br><span class="line"><span class="comment">//- index.pug 使用extends继承以上模板，通过block覆盖或替换原有块block</span></span><br><span class="line"><span class="keyword">extends</span> base.pug</span><br><span class="line">  </span><br><span class="line">block title</span><br><span class="line">    title <span class="string">&quot;Test title&quot;</span></span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">    h1 Hello world!</span><br><span class="line">    block article</span><br></pre></td></tr></table></figure></li><li><p>定义变量</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//- 通过`- var`定义</span></span><br><span class="line">- <span class="keyword">var</span> intData = <span class="number">100</span></span><br><span class="line">- <span class="keyword">var</span> boolData = <span class="literal">false</span></span><br><span class="line">- <span class="keyword">var</span> stringData = <span class="string">&#x27;Test&#x27;</span></span><br><span class="line"><span class="comment">//- 通过`=`引用</span></span><br><span class="line">p.int= intData</span><br><span class="line">p.bool= boolData</span><br><span class="line">p.stringData= stringData</span><br><span class="line"><span class="comment">//- 通过`#&#123;&#125;`连接其他字面量</span></span><br><span class="line">p #&#123;stringData&#125; is so good!</span><br></pre></td></tr></table></figure></li><li><p>条件结构</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> A</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> B</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p>迭代</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ol</span><br><span class="line">each item <span class="keyword">in</span> [<span class="string">&#x27;Sun&#x27;</span>, <span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tus&#x27;</span>, <span class="string">&#x27;Wen&#x27;</span>, <span class="string">&#x27;Thu&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>]</span><br><span class="line">    li= item</span><br></pre></td></tr></table></figure></li><li><p>Mixin 用于编写函数</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//- 定义函数</span></span><br><span class="line">mixin menu-item(href, name)</span><br><span class="line">li</span><br><span class="line">    span.dot ●</span><br><span class="line">    a(href=href)= name</span><br><span class="line"><span class="comment">//- 调用函数</span></span><br><span class="line">+menu-item(<span class="string">&#x27;/About&#x27;</span>,<span class="string">&#x27;About&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>Javascript</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">script(type=<span class="string">&#x27;text/javascript&#x27;</span>).</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&quot;Test&quot;</span></span><br><span class="line"><span class="keyword">var</span> enable = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> enable</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;nothing&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="scss介绍"><code>scss</code>介绍</h4><blockquote><p><code>scss</code>和<code>css</code>关系<br>scss 是 css的预处理器, 它的优势在于开发效率高, 对于一些样式复杂的站点, 用 scss 之类的工具生成代码比手写 css 快得多</p></blockquote><p>在这里我们通过<code>gulp</code>将<code>scss</code>转化为压缩的<code>css</code>, 即我们只用维护几个碎片的<code>scss</code>文件, 而不是直接修改<code>css</code>文件</p><h4 id="Hexo的变量">Hexo的变量</h4><p>在模版中为了渲染出具体的内容需要使用Hexo中的变量</p><p>变量非常多, 建议看<a href="https://hexo.io/zh-cn/docs/variables">官方文档</a>按需使用</p><h4 id="Hexo的函数">Hexo的函数</h4><p>在模版中也可以使用Hexo提供的函数, 可进行一些判断或作为工具</p><p>函数也非常多, 建议看<a href="https://hexo.io/zh-cn/docs/helpers">官方文档</a>按需使用</p></br><p>至此, 理论部分已经讲解完成, <a href="https://blog.xhyh.tech/tutorial/hexo-theme-dev/">下一篇</a>实践篇将利用这些知识以实际例子讲述如何开发和修改主题<br><br></p><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/tutorial/">tutorial</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/hexo/">hexo</category>
      
      <category domain="https://blog.xhyh.tech/tags/hexo-theme/">hexo-theme</category>
      
      
      <comments>https://blog.xhyh.tech/tutorial/hexo-theme-theory/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>用 Github Actions 将 Hexo 博客部署到 Github Page</title>
      <link>https://blog.xhyh.tech/tutorial/zero-to-hexo2/</link>
      <guid>https://blog.xhyh.tech/tutorial/zero-to-hexo2/</guid>
      <pubDate>Fri, 10 Apr 2020 02:43:08 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;a href=&quot;https://blog.xhyh.tech/tutorial/zero-to-hexo1/&quot;&gt;上篇博客&lt;/a&gt;中已经实现在本地预览博客, 本篇会将本地博客部署到Github Page&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://blog.xhyh.tech/tutorial/zero-to-hexo1/">上篇博客</a>中已经实现在本地预览博客, 本篇会将本地博客部署到Github Page</p><span id="more"></span><h3 id="配置Github-Actions">配置Github Actions</h3><p><code>Github Actions</code> 是 Github 推出的一款持续集成工具, 这里我们可以用来发布博客到 <code>Github Page</code></p><ol><li><p>新建workflow文件</p><p>只有当项目中<code>.github/workflows</code>目录下存在以<code>.yml</code>结尾的配置才会触发<code>Github Actions</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Blog</span><br><span class="line">mkdir -p .github/workflows</span><br><span class="line">touch .github/workflows/deploy.yml</span><br></pre></td></tr></table></figure></li><li><p>配置<code>deploy.yml</code>文件</p><p>最新版可以查看<a href="https://github.com/achjqz/blog/blob/master/.github/workflows/deploy.yml">我的配置</a></p></li><li><p>流程介绍</p><p>根据上面的配置可以看到主要分为4步</p></li></ol><ul><li>Checkout 拉取你的博客, 默认拉取本项目</li><li>安装Node环境</li><li>安装Hexo依赖</li><li>部署到Github Page</li></ul><h3 id="生成ssh私钥">生成ssh私钥</h3><p>有了ssh私钥可以实现免密码将博客推送到Github</p><p>具体配置可以参照<a href="https://blog.xhyh.tech/tutorial/linux-ssh/">Linux下的ssh配置</a>, 只用完成第一部分ssh生成</p><h3 id="将公钥添加到Github">将公钥添加到Github</h3><p>在 <code>push</code> 到Github时需要验证身份, 添加ssh公钥到Github, 本地使用私钥验证便有权限操控仓库</p><p>在Github账号设置中添加<code>ssh/id_rsa.pub</code>文件中的内容<br><img src="https://pic.rmb.bdstatic.com/6b5c9c8d97447ab0aad3da6af5439897.png" alt="ssh"></p><h3 id="生成ACCESS-SECRET">生成ACCESS_SECRET</h3><p>有了ACCESS_SECRET, <code>Github Actions</code> 才有权限写入仓库</p><p>可以在Github账户设置中生成一个<br><img src="https://pic.rmb.bdstatic.com/3e96456f3136c30e6daee91f21d00176.png" alt="token"></p><p>至少必须给<code>read, write repo</code>的权限<br>保存好生成的一串数字字母</p><h3 id="在Github上新建仓库">在Github上新建仓库</h3><ol><li>进入<a href="https://github.com/new">新建仓库页面</a></li><li>新建一个仓库, public和private均可, 但推荐public, 否则Github Page需要另外新建一个仓库<br><img src="https://pic.rmb.bdstatic.com/245f3c54feac8e15db0dae57ff18533c.png" alt="new repo"></li><li>在项目设置中添加<code>ACCESS_SECRET</code>, Value就是上面生成好的token<br><img src="https://pic.rmb.bdstatic.com/5b364db983b09727ee07df2a9dc54a99.png" alt="secret"></li><li>根据提示push项目</li></ol><h3 id="查看Github-Actions工作情况">查看<code>Github Actions</code>工作情况</h3><p>当 push 项目后, 在Actions选项中能看到已经自动运行部署<br><img src="https://pic.rmb.bdstatic.com/8cdc7826c558371149a5198b9fd6e43c.png" alt="workflow"></p><p>如果有报错信息, 则根据信息修改</p><h3 id="自定义域名设置">自定义域名设置</h3><p>在项目Settings中可以<a href="https://help.github.com/en/github/working-with-github-pages/configuring-a-custom-domain-for-your-github-pages-site">设置域名</a>并开启https<br><img src="https://pic.rmb.bdstatic.com/2e181936fe576fb0f0cf484f87d538ad.png" alt="setting"></p><div class="warning"><p>注意若设置的是子域名, 则需要在DNS设置中加入CNAME规则, 使子域名指向<code>username.github.io</code></p></div><h3 id="写作发布流程">写作发布流程</h3><p>至此, 应该能使用<code>username.github.io</code>访问你的博客了, 后续写作的流程是</p><ol><li><code>hexo new 'Hello world'</code> 生成新文章</li><li>写作</li><li><code>git add</code>,  <code>git commit</code>, <code>git push</code></li><li><code>Github Actions</code> 自动部署<br><br></li></ol><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/tutorial/">tutorial</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/hexo/">hexo</category>
      
      <category domain="https://blog.xhyh.tech/tags/blog/">blog</category>
      
      
      <comments>https://blog.xhyh.tech/tutorial/zero-to-hexo2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hello new blog</title>
      <link>https://blog.xhyh.tech/talk/hello-new-blog/</link>
      <guid>https://blog.xhyh.tech/talk/hello-new-blog/</guid>
      <pubDate>Wed, 08 Apr 2020 10:50:46 GMT</pubDate>
      
      <description>&lt;p&gt;最近闲了下来, 计划慢慢输出一点这段时间学习的内容, 便重新打理了一下博客&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近闲了下来, 计划慢慢输出一点这段时间学习的内容, 便重新打理了一下博客</p><span id="more"></span><h3 id="为什么不使用老博客">为什么不使用老博客</h3><ol><li><p>老博客基于<code>diygod</code>主题改造, 虽尽力保持简洁了很多, 但一段时间后发现还是不利于文章阅读</p></li><li><p><code>diygod</code> 主题过于复杂, 不利于修改和维护</p></li><li><p>老博客采用源码私库备份, <code>Github page</code> 部署的策略, 但非常不利于维护, 发布文章也不方便</p></li></ol><h3 id="新博客的优势">新博客的优势</h3><ol><li><p>更加简洁的外观</p></li><li><p>基于 <a href="https://github.com/achjqz/hexo-theme-apollo">apollo</a> 主题修改, 额外支持了<code>tag</code>显示和<code>category</code>界面</p></li><li><p>使用<code>Github Actions</code>持续集成, 语雀云端写作, 维护和写作更加方便</p></li></ol><h3 id="新博客的内容">新博客的内容</h3><ol><li><p>旧博客内容的整理, 升级</p></li><li><p>各种折腾的笔记</p></li><li><p>学习知识的整理输出</p></li><li><p>生活<br><br></p></li></ol><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/talk/">talk</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/blog/">blog</category>
      
      <category domain="https://blog.xhyh.tech/tags/summary/">summary</category>
      
      
      <comments>https://blog.xhyh.tech/talk/hello-new-blog/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux 下 ssh 的配置</title>
      <link>https://blog.xhyh.tech/tutorial/linux-ssh/</link>
      <guid>https://blog.xhyh.tech/tutorial/linux-ssh/</guid>
      <pubDate>Fri, 28 Sep 2018 08:25:43 GMT</pubDate>
      
      <description>&lt;p&gt;本文带你了解ssh, 如何实现ssh免密码登陆? 如何使用ssh做端口转发, 跳板?&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本文带你了解ssh, 如何实现ssh免密码登陆? 如何使用ssh做端口转发, 跳板?</p><span id="more"></span><h3 id="生成ssh-key">生成ssh key</h3><p>本文以Linux为例, 其他平台可参照<a href="https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">Github官方文档</a>操作</p><ol><li><p>生成2048位的密匙 <code>passphrase</code> 可以设置为空</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>设置权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .ssh directory: 700 (drwx------)</span></span><br><span class="line">chmod 700 .ssh</span><br><span class="line"><span class="comment"># public key (.pub file): 644 (-rw-r--r--)</span></span><br><span class="line">chmod 644 .ssh/id_rsa.pub</span><br><span class="line"><span class="comment"># private key (id_rsa): 600 (-rw-------)</span></span><br><span class="line">chmod 600 .ssh/id_rsa</span><br></pre></td></tr></table></figure></li></ol><h3 id="服务器设置">服务器设置</h3><ol><li><p>将公匙用<code>ssh-copy-id</code> 命令传给服务器,实现ssh免密码登陆</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@serverip</span><br></pre></td></tr></table></figure></li><li><p>服务器端设置<code>/etc/ssh/sshd_config</code>, 使得不能用密码登陆root用户</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置</span></span><br><span class="line">PermitRootLogin yes</span><br><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure></li><li><p>本地新建一个config文件,填入服务器信息,实现简化登陆</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch ~/.ssh/config</span><br><span class="line"><span class="comment"># config file</span></span><br><span class="line">Host name</span><br><span class="line">  Hostname serverip</span><br><span class="line">  User root</span><br></pre></td></tr></table></figure></li><li><p>查看服务器ssh登陆日志</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp name:/var/<span class="built_in">log</span>/btmp btmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选日志信息, 实现显示 次数+ IP</span></span><br><span class="line">lastb -f btmp | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure></li></ol><h3 id="ssh高级操作">ssh高级操作</h3><ol><li><p>实现端口转发,将服务器用作代理访问其他网站</p><p>命令: <code>ssh -N -f -L  \&lt;local port&gt;:\&lt;remote host&gt;:\&lt;remote port&gt; \&lt;SSH hostname&gt;</code></p><p>这样就将IP为remote host机器的remote port通过中间服务器映射到本地机器的localport</p><blockquote><p>解释:<br>-N 指这个连接不需要执行任何命令。仅仅做端口转发<br>-f 在后台运行<br>-L 做本地映射端口，被冒号分割的三个部分含义分别是<br>需要使用的本地端口号<br>​需要访问的目标机器IP地址<br>需要访问的目标机器端口</p></blockquote></li><li><p>将私匙添加到ssh-agent,避免每次都要输密码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># start ssh-agent</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line"><span class="comment"># add ssh key</span></span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></li><li><p>跳板登陆</p><p>本地A, 跳板服务器B, 目标服务器C</p><p>首先将本地A均可以ssh登陆B和C</p><p>当连接服务器B时,使用ssh -A命令,  以打开agent forwarding</p><p>当服务器B连接服务器C时, 就不用再输密码了, 相当于这台服务器充当了转发信息的功能,把私钥操作的request转发到了本机的agent, 然后再将agent的response原路返回<br><br></p></li></ol><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/tutorial/">tutorial</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/linux/">linux</category>
      
      <category domain="https://blog.xhyh.tech/tags/ssh/">ssh</category>
      
      <category domain="https://blog.xhyh.tech/tags/ssh-agent/">ssh-agent</category>
      
      
      <comments>https://blog.xhyh.tech/tutorial/linux-ssh/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>零基础搭建 Hexo 博客</title>
      <link>https://blog.xhyh.tech/tutorial/zero-to-hexo1/</link>
      <guid>https://blog.xhyh.tech/tutorial/zero-to-hexo1/</guid>
      <pubDate>Sat, 14 Apr 2018 14:18:32 GMT</pubDate>
      
      <description>&lt;p&gt;用 Hexo + Github 来搭建个人博客已经很普遍了, 正好 Github action 发布, 可以利用持续集成使得部署更加轻松 &lt;br&gt;
本文从零开始, 搭建 hexo 博客并用 Github Actions 发布到 Github Page&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>用 Hexo + Github 来搭建个人博客已经很普遍了, 正好 Github action 发布, 可以利用持续集成使得部署更加轻松 <br>本文从零开始, 搭建 hexo 博客并用 Github Actions 发布到 Github Page</p><span id="more"></span><h3 id="工具介绍及安装">工具介绍及安装</h3><ul><li><code>Git</code>  版本管理工具, 用于管理写的文章, 并和 Github 仓库建立连接, <a href="https://git-scm.com/">官网安装</a></li><li><code>node.js</code>  为 hexo 提供 JavaScript 环境 <a href="https://nodejs.org/">官网安装</a></li><li><code>Github Pages</code>   Github 官网提供的一个服务, 将博客部署到它上面, 避免自己购买服务器, 无需安装</li></ul><h3 id="hexo和主题安装">hexo和主题安装</h3><div class="info"><h4 id="hexo-和-hexo-主题的关系">hexo 和 hexo 主题的关系</h4><p>hexo 主题定义了博客的界面布局, 颜色, 脚本等, hexo 将内容渲染交给hexo 主题生成对应的排版</p></div><ol><li><p>hexo 安装<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></li><li><p>生成默认博客</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p>下载主题</p><p>这里以<code>apollo</code>主题为例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-renderer-pug\</span><br><span class="line"> hexo-generator-feed \</span><br><span class="line"> hexo-generator-sitemap \</span><br><span class="line"> hexo-browsersync  \</span><br><span class="line"> hexo-generator-archive</span><br><span class="line">npm i hexo-theme-apollo</span><br></pre></td></tr></table></figure><blockquote><p>hexo 5.0 支持使用npm安装主题</p></blockquote></li></ol><h3 id="博客配置">博客配置</h3><p>博客的配置主要都在<code>_config.yml</code>中</p><ol><li><p>主题相关配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># 修改主题名称</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">apollo</span></span><br></pre></td></tr></table></figure><blockquote><p>hexo 5.0 主题的具体配置移到了_config.apollo.yml中<br>更多配置说明请查看<a href="https://github.com/achjqz/hexo-theme-apollo/blob/master/docs/doc-zh.md">apollo</a>文档和参考<a href="https://github.com/achjqz/blog/blob/master/_config.yml">我的配置</a></p></blockquote></li><li><p>博客url配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">http://blog.xhyh.tech</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:category/:urlname/</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:year:month:day-:title.md</span></span><br></pre></td></tr></table></figure><div class="warning"><p>为方便整理, 生成新文章会有时间前缀, 而我们不希望在文章链接中包含时间, 这里使用了urlname, 需要在每篇文章头中添加这个变量</p></div></li></ol><h3 id="常用命令">常用命令</h3><ul><li><code>hexo clean</code>  清除缓存和生成的public文件夹</li><li><code>hexo g</code>  generator  生成public文件</li><li><code>hexo s</code>  server     本地预览, 加参数<code>--debug</code>可查看调试信息</li><li><code>hexo d</code>   deploy   部署到github</li></ul><h3 id="增加category-tag页面">增加category/tag页面</h3><p>默认并没有category, tag页面, 需要在命令行中输入命令添加</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page category</span><br></pre></td></tr></table></figure></br><p><a href="https://blog.xhyh.tech/tutorial/zero-to-hexo2/">下一篇</a>将介绍如何使用 Github Actions 部署博客<br><br></p><h3>转载申请</h3><p><a rel="license" class="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="zoom: 25%;display: inline" src="/images/by.png"></a></p><p>本文<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可，转载时请注明原文链接</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Hexo官网: <a href="https://hexo.io/">https://hexo.io/</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://blog.xhyh.tech/categories/tutorial/">tutorial</category>
      
      
      <category domain="https://blog.xhyh.tech/tags/hexo/">hexo</category>
      
      <category domain="https://blog.xhyh.tech/tags/blog/">blog</category>
      
      
      <comments>https://blog.xhyh.tech/tutorial/zero-to-hexo1/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
