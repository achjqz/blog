<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 汇编入门之 x86 和 x86_64 函数调用对比 --32位篇 · 潇晗宇浩的博客</title><meta name="description" content="上一篇中讲了64位程序函数的调用情况, 这一篇我们来看32位程序的调用规则, 如果还没有看过上一篇的, 先阅读完上篇再读本文"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/images/logo.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.xhyh.best/rss2.xml" title="潇晗宇浩的博客"><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/rss2.xml" title="潇晗宇浩的博客" type="application/rss+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="/categories/" target="_self">CATEGORY</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/achjqz" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/rss2.xml" target="_self">RSS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/friends/" target="_self">FRIENDS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">汇编入门之 x86 和 x86_64 函数调用对比 --32位篇</h1><div class="post-info">Apr 29, 2020<a class="tag-title" href="/tags/assembly/">#assembly</a><a class="tag-title" href="/tags/os/">#os</a></div><div class="post-content"><p>上一篇中讲了64位程序函数的调用情况, 这一篇我们来看32位程序的调用规则, 如果还没有看过上一篇的, 先阅读完上篇再读本文</p>
<a id="more"></a>

<h3 id="x86程序分析"><a href="#x86程序分析" class="headerlink" title="x86程序分析"></a>x86程序分析</h3><blockquote>
<p>默认gcc编译成64位程序, 加上-m32参数可编译为32位程序</p>
</blockquote>
<h4 id="Og优化级别下"><a href="#Og优化级别下" class="headerlink" title="-Og优化级别下"></a>-Og优化级别下</h4><p>首先看<code>add</code>函数</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">subl  <span class="number">$60</span>, %esp</span><br><span class="line">/* 栈保护代码</span><br><span class="line">movl  <span class="number">$20</span>, %edx</span><br><span class="line">movl  %gs:(%edx), %eax</span><br><span class="line">movl  %eax, <span class="number">44</span>(%esp)</span><br><span class="line">*/</span><br><span class="line">xorl  %eax, %eax</span><br><span class="line">movl  <span class="number">68</span>(%esp), %eax // a</span><br><span class="line">addl  <span class="number">64</span>(%esp), %eax // b</span><br><span class="line">addl  <span class="number">12</span>(%esp), %eax // array[<span class="number">2</span>]</span><br><span class="line">addl  <span class="number">8</span>(%esp), %eax  // array[<span class="number">1</span>]</span><br><span class="line">/* 栈保护代码</span><br><span class="line">movl  <span class="number">44</span>(%esp), %ecx</span><br><span class="line">xorl  %gs:(%edx), %ecx</span><br><span class="line"><span class="keyword">jne</span>  .L4</span><br><span class="line">*/</span><br><span class="line">addl  <span class="number">$60</span>, %esp</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>可以看出和64位程序差别不大, 只是在获取参数的时候使用了栈上的值而不是寄存器</p>
<p>再看<code>main</code>函数</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">leal  <span class="number">4</span>(%esp), %ecx</span><br><span class="line">andl  $-<span class="number">16</span>, %esp</span><br><span class="line">pushl -<span class="number">4</span>(%ecx)</span><br><span class="line">pushl %ebp</span><br><span class="line">movl  %esp, %ebp</span><br><span class="line">pushl  %esi</span><br><span class="line">pushl  %ebx</span><br><span class="line">pushl  %ecx  </span><br><span class="line"></span><br><span class="line">subl  <span class="number">$36</span>, %esp</span><br><span class="line">xorl  %eax, %eax</span><br><span class="line">movl  <span class="number">$4</span>, -<span class="number">40</span>(%ebp)</span><br><span class="line">movl  <span class="number">$5</span>, -<span class="number">36</span>(%ebp)</span><br><span class="line">movl  <span class="number">$6</span>, -<span class="number">32</span>(%ebp)</span><br><span class="line">pushl <span class="number">$8</span></span><br><span class="line">pushl <span class="number">$7</span></span><br><span class="line"><span class="keyword">call</span>  <span class="keyword">add</span></span><br><span class="line">addl  <span class="number">$12</span>, %esp</span><br><span class="line">pushl %eax</span><br><span class="line">leal  .LC0@GOTOFF(%ebx), %eax</span><br><span class="line">pushl %eax</span><br><span class="line">pushl <span class="number">$1</span></span><br><span class="line"><span class="keyword">call</span>  __printf_chk@PLT</span><br><span class="line">addl  <span class="number">$16</span>, %esp</span><br></pre></td></tr></table></figure>

<p><code>main</code>函数前面一段多了很多奇怪的指令, <code>ebp</code>这一套上一篇已经说过了, 这里即使开启了优化也保留了<code>ebp</code></p>
<p>而后面几条<code>pushl</code>保存了几个寄存器的值, 属于<code>Callee Saved</code>, 函数运行结束时会<code>popl</code>还原</p>
<p>前三条命令有点迷惑, 查了下资料看到了一些解释</p>
<p><code>leal 4(%esp), %ecx</code> 将<code>main</code>函数第一个参数放入寄存器<code>ecx</code>中, 便于后面访问</p>
<p><code>andl $-16, %esp</code>    将<code>esp</code>地址与16字节对齐(<code>-16 = 0xfffffff0</code>)</p>
<p><code>pushl  -4(%ecx)</code>    存储函数的返回地址, 暂不知道作用</p>
<p>后面调用函数时并没有将参数压入寄存器, 而是使用<code>push</code>命令压栈, 函数调用结束后使用<code>add</code>命令释放, 这点和64位下多参数情况一致</p>
<h4 id="无优化下"><a href="#无优化下" class="headerlink" title="无优化下"></a>无优化下</h4><p><code>add</code>函数</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">pushl %ebp</span><br><span class="line">movl  %esp, %ebp</span><br><span class="line">subl  <span class="number">$56</span>, %esp</span><br><span class="line">xorl  %eax, %eax</span><br><span class="line">movl  <span class="number">8</span>(%ebp), %edx    // a</span><br><span class="line">movl  <span class="number">12</span>(%ebp), %eax   // b</span><br><span class="line">addl  %eax, %edx</span><br><span class="line">movl  -<span class="number">44</span>(%ebp), %eax  // array[<span class="number">2</span>]</span><br><span class="line">addl  %eax, %edx</span><br><span class="line">movl  -<span class="number">48</span>(%ebp), %eax  // array[<span class="number">1</span>]</span><br><span class="line">addl  %edx, %eax</span><br><span class="line">movl  -<span class="number">12</span>(%ebp), %ecx</span><br><span class="line"><span class="keyword">leave</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>可以看出仅仅是使用了<code>ebp</code></p>
<p>再看<code>main</code>函数</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">leal  <span class="number">4</span>(%esp), %ecx</span><br><span class="line">andl  $-<span class="number">16</span>, %esp</span><br><span class="line">pushl -<span class="number">4</span>(%ecx)</span><br><span class="line">pushl %ebp</span><br><span class="line">movl  %esp, %ebp</span><br><span class="line">pushl %ebx</span><br><span class="line">pushl %ecx</span><br><span class="line">subl  <span class="number">$32</span>, %esp</span><br><span class="line">xorl  %eax, %eax</span><br><span class="line">movl  <span class="number">$4</span>, -<span class="number">24</span>(%ebp)</span><br><span class="line">movl  <span class="number">$5</span>, -<span class="number">20</span>(%ebp)</span><br><span class="line">movl  <span class="number">$6</span>, -<span class="number">16</span>(%ebp)</span><br><span class="line">movl  <span class="number">$7</span>, -<span class="number">32</span>(%ebp)</span><br><span class="line">movl  <span class="number">$8</span>, -<span class="number">28</span>(%ebp)</span><br><span class="line">subl  <span class="number">$8</span>, %esp</span><br><span class="line">pushl -<span class="number">28</span>(%ebp)</span><br><span class="line">pushl -<span class="number">32</span>(%ebp)</span><br><span class="line"><span class="keyword">call</span>  <span class="keyword">add</span></span><br><span class="line">addl  <span class="number">$16</span>, %esp</span><br><span class="line">subl  <span class="number">$8</span>, %esp</span><br><span class="line">pushl %eax</span><br><span class="line">leal  .LC0@GOTOFF(%ebx), %eax</span><br><span class="line">pushl %eax</span><br><span class="line"><span class="keyword">call</span>  printf@PLT</span><br></pre></td></tr></table></figure>

<p>可以看到<code>main</code>函数和优化过的没有大的区别, 只是<code>printf</code>并没有被优化</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的分析下来, 64位程序和32位程序差别不大, 仅是参数传递的差异, 而当64位参数过多时, 也会采用32位压栈的方式传参</p>
<p>而不同优化级别下, 最大的差别就是使用<code>rsp</code>作为函数基地址还是<code>rbp</code>作为函数基地址</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/tutorial/wsl2-gui/">上一篇</a><a class="next" href="/study/assembly-function-call-64/">下一篇</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script>const gitalk = new Gitalk({
    clientID: '1ad726ece750d0552748',     
    clientSecret: '6917691391883046d263b52a7107fab68e457194',     
    id: window.location.pathname,    
    repo: 'blog',     
    owner: 'achjqz',     
    admin: 'achjqz',     
})   
gitalk.render('gitalk-container')
</script><div class="copyright"><p>© 2020 <a href="http://blog.xhyh.best">xhyh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/achjqz/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-117536047-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-117536047-1');</script></body></html>