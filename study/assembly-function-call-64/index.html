<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 汇编入门-x86和x86_64函数调用对比-64位篇 · 潇晗宇浩的博客</title><meta name="description" content="原来一直对64位程序的汇编函数调用比较熟悉, 32位程序的函数调用总觉得十分复杂. 本文主要对64位程序在不同优化级别下的汇编函数调用实现情况, 后篇再结合32位进行对比分析"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.xhyh.best/rss2.xml" title="潇晗宇浩的博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/rss2.xml" title="潇晗宇浩的博客" type="application/rss+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="/categories/" target="_self">CATEGORY</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/achjqz" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/rss2.xml" target="_self">RSS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/friends/" target="_self">FRIENDS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">汇编入门-x86和x86_64函数调用对比-64位篇</h1><div class="post-info">Apr 28, 2020<a class="tag-title" href="/tags/assembly/">#assembly</a><a class="tag-title" href="/tags/os/">#os</a></div><div class="post-content"><p>原来一直对64位程序的汇编函数调用比较熟悉, 32位程序的函数调用总觉得十分复杂. 本文主要对64位程序在不同优化级别下的汇编函数调用实现情况, 后篇再结合32位进行对比分析</p>
<a id="more"></a>
<h3 id="说明">说明</h3>
<h4 id="汇编格式">汇编格式</h4>
<p>如果对汇编指令还不熟悉可以看<a href="https://blog.xhyh.best/study/assembly-instructions/">上一篇</a>文章, 本文还是采用<code>AT&amp;T</code>汇编格式</p>
<h4 id="优化级别">优化级别</h4>
<p>在编译时, 可以指定代码的优化级别, 大致优化级别有如下几个</p>
<ul>
<li>-O (相当于 -O1)</li>
<li>-O0 (不优化, 默认级别)</li>
<li>-O1 (不影响编译速度的前提下，尽量采用一些优化算法降低代码大小和可执行代码的运行速度)</li>
<li>-O2 (牺牲部分编译速度, 优化更多)</li>
<li>-O3 (采取很多向量化算法，提高代码的并行执行程度)</li>
<li>-Ofast (不会严格遵循语言标准, 优化更多)</li>
<li>-Og (提供合理的优化水平，同时产生较好的可调试信息)</li>
<li>-Os (尽量降低目标代码的大小)</li>
</ul>
<blockquote>
<p>如果优化级别太高会出现和源代码完全不符的情况, 如函数调用会被优化掉, 出现汇编中没有调用函数的现象</p>
</blockquote>
<p>本文主要分析不优化和<code>-Og</code>两种情况</p>
<h4 id="源代码">源代码</h4>
<p>为了简便, 下面分析将采用以下源代码</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="dt">int</span> add(<span class="dt">int</span> a, <span class="dt">int</span> b) {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="dt">int</span> array[<span class="dv">10</span>];</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="cf">return</span> a + b  + array[<span class="dv">2</span>] + array[<span class="dv">1</span>];</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>}</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    <span class="dt">int</span> array[] = {<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>};</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>    <span class="dt">int</span> a = <span class="dv">7</span>, b = <span class="dv">8</span>;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    printf(<span class="st">&quot;sum: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, add(a, b));</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++) {</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>        printf(<span class="st">&quot;%d &quot;</span>, array[i]);</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>    }</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="x86_64程序分析">x86_64程序分析</h3>
<h4 id="og优化级别下">-Og优化级别下</h4>
<p>首先看<code>add</code>函数的汇编代码(已省去无关指令)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>subq<span class="bn">    $56, </span>%<span class="kw">rsp</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>/* 栈保护代码</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>movl<span class="bn">    $40, </span>%<span class="kw">edx</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="bu">movq</span>    %<span class="kw">fs</span>:(%<span class="kw">rdx</span>), %<span class="kw">rax</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="bu">movq</span>    %<span class="kw">rax</span>, <span class="dv">40</span>(%<span class="kw">rsp</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>*/</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>xorl    %<span class="kw">eax</span>, %<span class="kw">eax</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>addl    %<span class="kw">esi</span>, %<span class="kw">edi</span>      // a + b</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>addl    <span class="dv">8</span>(%<span class="kw">rsp</span>), %<span class="kw">edi</span>   // array[<span class="dv">2</span>]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>movl    %<span class="kw">edi</span>, %<span class="kw">eax</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>addl    <span class="dv">4</span>(%<span class="kw">rsp</span>), %<span class="kw">eax</span>   // array[<span class="dv">1</span>]</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>/* 栈保护代码</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span class="bu">movq</span>    <span class="dv">40</span>(%<span class="kw">rsp</span>), %<span class="kw">rcx</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>xorq    %<span class="kw">fs</span>:(%<span class="kw">rdx</span>), %<span class="kw">rcx</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a><span class="bu">jne</span> .L4</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>*/</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>addq<span class="bn">    $56, </span>%<span class="kw">rsp</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a><span class="bu">ret</span></span></code></pre></div>
<blockquote>
<p>可以看到函数中存在栈保护代码, 这里暂且不说, 与函数调用关系不大, 后面的代码中将省略</p>
</blockquote>
<p>首先看出程序会计算出<code>add</code>函数内需要的栈空间, 这里我们开了长度为10的<code>int</code>数组, 需要40字节, 栈保护需要8字节, 在使用<code>call</code>调用函数时已经将返回地址8字节压入栈中, 为了使栈内存和16字节对齐, 所以第一步将栈顶指针下移了56字节(56+8 是16的倍数)</p>
<p><code>rsp + 40</code>的位置用于存放栈保护内容, 而<code>rsp</code>, <code>rsp + 4</code> 则依次存放数组元素<code>array[0]</code>, <code>array[1]</code></p>
<p><code>eax</code>寄存器作为返回值, 首先通过<code>xor</code>置0</p>
<p>函数的参数依次存放在<code>edi</code>, <code>esi</code> 寄存器中, 使用<code>add</code>指令累加</p>
<p>最后将栈指针上移56字节, 回到调用函数前的状态</p>
<p>再看<code>main</code>函数</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>pushq   %<span class="kw">rbx</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>subq<span class="bn">    $32, </span>%<span class="kw">rsp</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>movl<span class="bn">    $4, </span><span class="dv">12</span>(%<span class="kw">rsp</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>movl<span class="bn">    $5, </span><span class="dv">16</span>(%<span class="kw">rsp</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>movl<span class="bn">    $6, </span><span class="dv">20</span>(%<span class="kw">rsp</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>movl<span class="bn">    $8, </span>%<span class="kw">esi</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>movl<span class="bn">    $7, </span>%<span class="kw">edi</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="bu">call</span>    <span class="bu">add</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>movl    %<span class="kw">eax</span>, %<span class="kw">edx</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>leaq    .LC0(%rip), %<span class="kw">rsi</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>movl<span class="bn">    $1, </span>%<span class="kw">edi</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>movl<span class="bn">    $0, </span>%<span class="kw">eax</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a><span class="bu">call</span>    __printf_chk@PLT</span></code></pre></div>
<p>除了一开始在栈上保存了<code>rbx</code>以外, 其它步骤基本和<code>add</code>函数一致, 也可以看到函数传参的过程(<code>mov</code>到相应寄存器)</p>
<blockquote>
<p>注意这里编译器自动优化, 将printf转换成了更安全的__printf_chk(int flag, const char * format)函数, 所以会多一个参数flag</p>
</blockquote>
<h4 id="无优化下">无优化下</h4>
<p>首先还是先看<code>add</code>函数</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>pushq   %<span class="kw">rbp</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="bu">movq</span>    %<span class="kw">rsp</span>, %<span class="kw">rbp</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>subq<span class="bn">    $64, </span>%<span class="kw">rsp</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>movl    %<span class="kw">edi</span>, <span class="dv">-52</span>(%<span class="kw">rbp</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>movl    %<span class="kw">esi</span>, <span class="dv">-56</span>(%<span class="kw">rbp</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>/* 栈保护</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="bu">movq</span>    %<span class="kw">fs</span>:<span class="dv">40</span>, %<span class="kw">rax</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a><span class="bu">movq</span>    %<span class="kw">rax</span>, <span class="dv">-8</span>(%<span class="kw">rbp</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>*/</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>xorl    %<span class="kw">eax</span>, %<span class="kw">eax</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>movl    <span class="dv">-52</span>(%<span class="kw">rbp</span>), %<span class="kw">edx</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>movl    <span class="dv">-56</span>(%<span class="kw">rbp</span>), %<span class="kw">eax</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>addl    %<span class="kw">eax</span>, %<span class="kw">edx</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>movl    <span class="dv">-40</span>(%<span class="kw">rbp</span>), %<span class="kw">eax</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>addl    %<span class="kw">eax</span>, %<span class="kw">edx</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>movl    <span class="dv">-44</span>(%<span class="kw">rbp</span>), %<span class="kw">eax</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>addl    %<span class="kw">edx</span>, %<span class="kw">eax</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>/* 栈保护</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a><span class="bu">movq</span>    <span class="dv">-8</span>(%<span class="kw">rbp</span>), %<span class="kw">rcx</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>xorq    %<span class="kw">fs</span>:<span class="dv">40</span>, %<span class="kw">rcx</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>*/</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a><span class="bu">leave</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a><span class="bu">ret</span></span></code></pre></div>
<p>与优化过的代码相比, 最大的变化就是使用了<code>rbp</code>寄存器</p>
<p><code>rbp</code>存储当前函数的基地址, 一个正在执行的函数A, <code>rsp</code>是 A 的栈顶, <code>rbp</code> 是 A 的栈底 <img src="https://pic.rmb.bdstatic.com/d54c105690f8ff541982deae78df5457.png" alt="stack-frame" /></p>
<p>函数调用规定了被调用者需存储调用者的<code>rbp</code>信息(Callee Saved), 并且在函数执行结束时恢复</p>
<p>于是, 使用<code>rbp</code>这一套的模板大概如下</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>pushq   %<span class="kw">rbp</span> // 存储调用者的rbp</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="bu">movq</span>    %<span class="kw">rsp</span>, %<span class="kw">rbp</span> // 将rbp设置为当前函数的基地址</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>subq<span class="bn">    $64, </span>%<span class="kw">rsp</span> // 为局部变量预留空间</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>... // 使用rbp作为内存寻址的基地址</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="bu">leave</span> // <span class="bu">mov</span> %<span class="kw">rbp</span>, %<span class="kw">rsp</span> 和 <span class="bu">pop</span> %<span class="kw">rbp</span> 指令的结合 </span></code></pre></div>
<blockquote>
<p>可以看到, 尽管使用rbp寻址, 但仍有subq $64, %rsp操作, 这是为了避免在调用函数时可能的push操作造成和局部变量数据冲突</p>
</blockquote>
<h4 id="多参数的情况">多参数的情况</h4>
<p>在64位程序中, 函数的参数会依次存在<code>%rdi, %rsi, %rdx, %rcx, %r8, %r9</code>, 这6个寄存器中, 如果参数多于6个怎么处理呢? 下面看一个例子</p>
<p>修改<code>add</code>函数接收7个参数</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="dt">int</span> add(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> c, <span class="dt">int</span> d, <span class="dt">int</span> e, <span class="dt">int</span> f, <span class="dt">int</span> g) {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>    <span class="dt">int</span> array[<span class="dv">10</span>];</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span class="cf">return</span> a + b + c + d + e + f + g + array[<span class="dv">2</span>] + array[<span class="dv">1</span>];</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>对应的汇编代码为(-Og优化)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>// <span class="bu">add</span> 函数</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>subq<span class="bn">    $56, </span>%<span class="kw">rsp</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>addl    %<span class="kw">esi</span>, %<span class="kw">edi</span> //a + b</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>addl    %<span class="kw">edx</span>, %<span class="kw">edi</span> // c</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>addl    %<span class="kw">ecx</span>, %<span class="kw">edi</span> // d</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>addl    %r8d, %<span class="kw">edi</span> // e</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>addl    %r9d, %<span class="kw">edi</span> // f</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>movl    %<span class="kw">edi</span>, %<span class="kw">eax</span>  </span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>addl    <span class="dv">64</span>(%<span class="kw">rsp</span>), %<span class="kw">eax</span> // g</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>addl    <span class="dv">8</span>(%<span class="kw">rsp</span>), %<span class="kw">eax</span> // array[<span class="dv">1</span>]</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>addl    <span class="dv">4</span>(%<span class="kw">rsp</span>), %<span class="kw">eax</span> // array[<span class="dv">0</span>]</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>addq<span class="bn">    $56, </span>%<span class="kw">rsp</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>// main 函数</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>pushq<span class="bn">   $0       </span>// g</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>movl<span class="bn">    $0, </span>%r9d // f</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>movl<span class="bn">    $0, </span>%r8d // e</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>movl<span class="bn">    $0, </span>%<span class="kw">ecx</span> // d</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>movl<span class="bn">    $0, </span>%<span class="kw">edx</span> // c</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>movl<span class="bn">    $8, </span>%<span class="kw">esi</span> // b</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a>movl<span class="bn">    $7, </span>%<span class="kw">edi</span> // a</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a><span class="bu">call</span>    <span class="bu">add</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a>addq<span class="bn">    $16, </span>%<span class="kw">rsp</span></span></code></pre></div>
<p>可以看到, 在main函数中通过<code>push</code>操作将第7个参数压栈, 调用完成后通过<code>add</code>释放栈空间 这也是上面说的为什么即使有<code>rbp</code>作为基地址, 仍然要移动<code>rsp</code>的原因</p>
<p></br></p>
<p>本文大致讲了两种函数调用的方式, 可以看出, 仅使用<code>rsp</code>代码会简洁不少, 而<code>rbp</code>方式仅仅是方便于调试, 所以在开了优化的情况下, 一般会被编译为<code>rsp</code>方式</p>
<p>下一篇将讲述32位程序的情况, 并与64位程序做一个对比总结</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/study/assembly-function-call-32/">上一篇</a><a class="next" href="/tutorial/mpv-config/">下一篇</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script>const gitalk = new Gitalk({
    clientID: '1ad726ece750d0552748',     
    clientSecret: '6917691391883046d263b52a7107fab68e457194',     
    id: window.location.pathname,    
    repo: 'blog',     
    owner: 'achjqz',     
    admin: 'achjqz',     
})   
gitalk.render('gitalk-container')
</script><div class="copyright"><p>© 2020 <a href="http://blog.xhyh.best">xhyh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/achjqz/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/styles/github-gist.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/highlight.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/dockerfile.min.js"></script><script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.0/languages/x86asm.min.js"></script><script>hljs.initHighlightingOnLoad();</script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-117536047-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-117536047-1');</script></body></html>