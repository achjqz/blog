<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 理解内存映射和 mmap · 潇晗宇浩的博客</title><meta name="description" content="以前总是对mmap的作用很迷惑, 特别是在用户态和内核态概念引入之后就更加疑惑, 为什么mmap可以做到零拷贝?本篇主要是梳理虚拟内存, 内存, 磁盘以及mmap之间的关系"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/images/logo.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.xhyh.best/rss2.xml" title="潇晗宇浩的博客"><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/rss2.xml" title="潇晗宇浩的博客" type="application/rss+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="/categories/" target="_self">CATEGORY</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/achjqz" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/rss2.xml" target="_self">RSS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/friends/" target="_self">FRIENDS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">理解内存映射和 mmap</h1><div class="post-info">Aug 2, 2020<a class="tag-title" href="/tags/os/">#os</a><a class="tag-title" href="/tags/mmap/">#mmap</a></div><div class="post-content"><p>以前总是对mmap的作用很迷惑, 特别是在用户态和内核态概念引入之后就更加疑惑, 为什么mmap可以做到零拷贝?本篇主要是梳理虚拟内存, 内存, 磁盘以及mmap之间的关系</p>
<a id="more"></a>

<h3 id="什么是mmap"><a href="#什么是mmap" class="headerlink" title="什么是mmap"></a>什么是mmap</h3><p>先来看<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mmap">维基百科</a>的解释</p>
<blockquote>
<p>mmap是POSIX兼容的Unix系统调用, 它将文件或设备映射到内存中.<br>这是一种内存映射文件I / O的方法, 它实现了按需分页, 因为文件内容不直接从磁盘读取, 并且最初根本不使用物理RAM</p>
</blockquote>
<p>翻译得好听一点就是:</p>
<ol>
<li>是一个系统调用</li>
<li>可以将内存和文件映射</li>
<li>不直接从磁盘读取文件内容, 最初也不占用内存</li>
</ol>
<p>要理解这几条概念首先得知道虚拟内存和分页技术</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><blockquote>
<p>具体虚拟内存为什么存在, 解决了哪些问题, 有什么优点可以单开一章来讲, 这里只讲一些便于理解mmap的东西</p>
</blockquote>
<p>理论上讲, 虚拟内存就是存储在<strong>磁盘</strong>上的连续N个字节, 而物理内存则是这些内容的缓存</p>
<p><img src="https://pic.rmb.bdstatic.com/bjh/2bfa5b6707d571d59bf0a8b26e5f62a8.png" alt="virtual-memory"></p>
<p>如果以1个字节为单位, 那么每次从磁盘载入进物理内存的效率会非常低, 于是虚拟内存以页为单位存储, 一个页通常是4kb</p>
<p>那操作系统是如何知道哪些内容被缓存了, 哪些还在磁盘上呢?</p>
<p>在物理内存里会给每个进程维护一张页表, 当进程使用虚拟地址进行访问内存时, 查页表可知这个页是否已经被加载到物理内存里了</p>
<p><img src="https://pic.rmb.bdstatic.com/bjh/05ff3794951778d5be6722d682d3865b.png" alt="page-table"></p>
<h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><p>虚拟内存里面的内容究竟是什么呢?</p>
<p>在虚拟内存初始化的时候, 有两种途径</p>
<ol>
<li>映射存在磁盘上的普通文件(如可执行的二进制文件)</li>
<li>映射匿名文件(加载进物理内存时初始化全为0)</li>
</ol>
<p>虚拟内存初始化的过程, 就叫做内存映射</p>
<p>通过理解以上两点, 可以解释mmap的概念了</p>
<ol>
<li>mmap就是做内存映射的一个系统调用</li>
<li>虚拟内存是存在磁盘上的, 所以内存映射后初始不占据物理内存, 按需从磁盘载入进物理内存</li>
</ol>
<h3 id="怎么用mmap"><a href="#怎么用mmap" class="headerlink" title="怎么用mmap"></a>怎么用mmap</h3><h4 id="操作系统中内存映射使用的场景"><a href="#操作系统中内存映射使用的场景" class="headerlink" title="操作系统中内存映射使用的场景"></a>操作系统中内存映射使用的场景</h4><ol>
<li><p>加载可执行程序</p>
<p> 如果不做内存映射的话, 需要先把可执行程序全部读入物理内存中, 再进行命令执行</p>
<p> 这显然是十分低效且不可行的做法, 如果可执行程序比物理内存还大, 运行都无法成功</p>
<p> 采用内存映射, 首先先把可执行程序代码段的内容映射到虚拟内存中, cpu执行指令时发现有缺页错误, 再从磁盘中载入到物理内存里来</p>
</li>
<li><p>共享数据</p>
<p> 很多程序都会使用同样的系统共享库, 这些共享库不需要复制多份, 通过内存映射的方式可以使用同一份磁盘上的内容</p>
<p> <img src="https://pic.rmb.bdstatic.com/bjh/5fee85e39a785c251584487e482390ea.png" alt="share-object"></p>
</li>
</ol>
<blockquote>
<p>私有对象可以采用写时复制技术防止原有数据被修改</p>
</blockquote>
<h4 id="用户级别内存映射的使用"><a href="#用户级别内存映射的使用" class="headerlink" title="用户级别内存映射的使用"></a>用户级别内存映射的使用</h4><p>mmap就是内核提供的, 可以像操作系统一样做内存映射的一个系统调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">int</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">int</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>start</strong>: 指定开始的虚拟地址, 0 表示任意挑选一个地址</p>
<p><strong>len fd offset</strong>: 从fd指定的文件offet位置开始映射len个字节</p>
<p><strong>prot</strong>: PROT_READ, PROT_WRITE, PROT_EXEC…</p>
<p><strong>flags</strong>: MAP_ANON, MAP_PRIVATE, MAP_SHARED…</p>
<p>返回值: 一个虚拟地址指针, 可能不是start指定的(kernel决定真正映射的地址)</p>
<p><img src="https://pic.rmb.bdstatic.com/bjh/08ae83cd9ea18dfe208774a9ce8b8bda.png" alt="mmap"></p>
<ol>
<li><p>读取大文件</p>
<p> read读取文件流程: read系统调用-&gt;内核将文件内容读取到内核缓冲区-&gt;内核将缓冲区内容拷贝到用户空间</p>
<p> mmap读取文件流程: mmap系统调用-&gt;内核进行内存映射-&gt;用户使用数据-&gt;发生缺页异常-&gt;从磁盘载入数据</p>
</li>
<li><p>进程间通讯</p>
<p> 进程之间的数据本身是无法互通的(虚拟地址空间), 而通过mmap内存映射的方式, 将同一个文件映射到虚拟内存中, 那么对这个文件的修改都是跨进程可见的</p>
</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/talk/question-and-answer/">上一篇</a><a class="next" href="/tutorial/wsl2-gui/">下一篇</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script>const gitalk = new Gitalk({
    clientID: '1ad726ece750d0552748',     
    clientSecret: '6917691391883046d263b52a7107fab68e457194',     
    id: window.location.pathname,    
    repo: 'blog',     
    owner: 'achjqz',     
    admin: 'achjqz',     
})   
gitalk.render('gitalk-container')
</script><div class="copyright"><p>© 2020 <a href="http://blog.xhyh.best">xhyh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/achjqz/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN" crossorigin="anonymous"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-117536047-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-117536047-1');</script></body></html>